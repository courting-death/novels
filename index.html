<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Martial Peak — Reader</title>

  <!-- Markdown renderer -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- Noto Serif & Noto Sans loaded from Google Fonts. Request only 400 and 700 to reduce download size. -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;700&family=Noto+Sans:wght@400;700&display=swap" rel="stylesheet">

  <style>
    /* THEME TOKENS */
    :root[data-theme="white"] {
  --bg: #ffffff;           /* pure white */
  --fg: #1f2328;           /* near-black text */
  --muted: #6e7781;        /* neutral muted */
  --primary: #0969da;      /* GitHub-like blue */
  --surface: #f6f8fa;      /* light gray surface */
  --border: #d0d7de;       /* neutral border */
  --link: #0969da;         /* link blue */
    }
    :root[data-theme="light"] {
  --bg: #f4ecd8;           /* sepia background, less yellow */
  --fg: #5b4636;           /* readable brown text */
  --muted: #a58c6f;        /* muted brown */
  --primary: #b5853e;      /* warm accent */
  --surface: #f7f3e6;      /* lighter sepia for surfaces, less yellow */
  --border: #e0d6c3;       /* soft border */
  --link: #a86b32;         /* brownish link */
    }
    :root[data-theme="dark"] {
  --bg: #18222d;           /* deep blue-gray background */
  --fg: #c7d4e6;           /* cool light blue text */
  --muted: #6b7a8f;        /* muted blue-gray */
  --primary: #4f8cc9;      /* blue accent */
  --surface: #223042;      /* lighter blue-gray for surfaces */
  --border: #2c3a4d;       /* soft blue border */
  --link: #7ec3fa;         /* bright blue link */
    }
    :root[data-theme="black"] {
  --bg: #0d1117;           /* GitHub dark */
  --fg: #e6edf3;           /* light text */
  --muted: #7d8590;        /* muted gray */
  --primary: #2f81f7;      /* accent blue */
  --surface: #161b22;      /* dark surface */
  --border: #30363d;       /* border gray */
  --link: #2f81f7;         /* link blue */
    }
    
    /* ====== Layout tokens (tweak these to change spacing/sizes globally) ======
       --header-h: height of the top header
       --settings-rail-w: width of the right-side settings rail
       --icon-btn-size: square hit area for small header/rail buttons (do NOT confuse with glyph size)
       --icon-glyph-size: visual size of the SVG icon inside the button
    */
    :root { 
      --header-h: 56px; /* adjust if you like */
      --settings-rail-w: 72px; /* change to widen/narrow the settings rail in one place */
      --icon-btn-size: 42px;   /* hit/touch area for .icon-btn */
      --icon-glyph-size: 20px; /* visual size of the SVG glyph inside the button */
  /* global font family used across the site (can be toggled via settings) */
  --global-font-family: 'Noto Serif', serif;
  /* global font weight (400 recommended) */
  --global-font-weight: 400;
    }
    header.site-header { min-height: var(--header-h); }

    :root{
      --content-w: 72ch; /* comfortable line length: ~70–75 characters */
    }

    


    /* LAYOUT */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      /* use the global font family so the whole UI follows the selected Noto family */
      font: 16px/1.6 var(--global-font-family, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji");
  font-weight: var(--global-font-weight, 400);
    }

    /* global hidden helper (keeps layout space like your .nav rule) */
    .hidden { visibility: hidden; }


    .app {
      display: grid;
      grid-template-columns: 280px 1fr;
      height: 100vh;
      transition: grid-template-columns .2s ease;
    }
    /* desktop collapse state */
    body.sidebar-collapsed .app { grid-template-columns: 0 1fr; }
    /* you already have: body.sidebar-collapsed .app { grid-template-columns: 0 1fr; } */
    body.sidebar-collapsed .sidebar {
      width: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
      border: 0 !important;
      overflow: hidden !important;
    }
    body.sidebar-collapsed .sidebar * { display: none !important; } /* hide children so nothing paints */


    /* SIDEBAR */
    .sidebar {
      background: var(--surface);
      border-right: 1px solid var(--border);
      padding: 12px;
  overflow-y: auto;
  /* Always allow scrolling on hover, no click needed */
      position: relative;
  z-index: 1100; /* above the overlay */
    }

    .sidebar h1{
    text-align:center;
    margin: 6px 0 10px;
    font-size: 18px;
    font-weight: 700;
    }

    .chapter-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .no-results {
      padding: 10px;
      margin: 8px 0;
      text-align: center;
      color: var(--muted);
      font-size: 14px;
    }
    .no-results.hidden { display: none; }
    /* Chapter search input inside the left sidebar */
    .chapter-search {
      width: 100%;
      box-sizing: border-box;
  padding: 8px 10px;
  padding-right: 40px; /* space for the clear button */
      margin: 6px 0 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--fg);
      font: inherit;
    }
    /* Hide native browser 'clear' / search-cancel decorations so only our clear button is shown */
    .chapter-search::-webkit-search-decoration,
    .chapter-search::-webkit-search-cancel-button,
    .chapter-search::-webkit-search-results-button,
    .chapter-search::-webkit-search-results-decoration {
      display: none !important;
      -webkit-appearance: none;
    }
    /* wrapper so we can place a clear button inside the input area */
    .chapter-search-wrap { position: relative; }
    .chapter-search-clear {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      border: none;
      background: transparent;
      color: var(--muted);
      width: 28px;
      height: 28px;
      display: inline-grid;
      place-items: center;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      padding: 0;
  z-index: 2; /* ensure it sits above the input text */
    }
    .chapter-search-clear:hover { color: var(--fg); }
    /* Remove browser outline but provide a subtle theme-aware focus ring */
    .chapter-search:focus {
      outline: none;
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 12%, transparent);
      border-color: var(--primary);
    }
    /* placeholder color should adapt to the theme */
    .chapter-search::placeholder { color: color-mix(in srgb, var(--muted) 70%, transparent); }
    /* make clear button visually hidden when input is empty */
    .chapter-search-clear.hidden { display: none; }
    .chapter-list a {
      display: block;
      padding: 8px 10px;
      border-radius: 8px;
      color: var(--fg);
      text-decoration: none;
      border: 1px solid transparent;
    }
    .chapter-list a:hover {
      background: rgba(127,127,127,.08);
      border-color: var(--border);
    }
    .chapter-list a.active {
      background: rgba(99,102,241,0.12);
      border-color: var(--primary);
      color: var(--primary);
      font-weight: 600;
    }

    /* keep the layout inside the viewport on every device */
    html, body { overflow-x: hidden; }

    /* prevent long titles from stretching the header */
    #chapterTitle {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* keep chapter content within the screen */
    article#article {
      max-width: 100%;
      overflow-wrap: anywhere;   /* handles super-long words/links */
      word-break: break-word;
    }

    /* make wide content responsive */
    article#article img,
    article#article table,
    article#article iframe {
      max-width: 100%;
      height: auto;
    }


    /* CONTENT */
    /* Let the whole right column scroll so the scrollbar is at the viewport edge */
    /* Right column no longer scrolls itself */
    .content {
      display: flex;
      flex-direction: column;
      min-width: 0;
      min-height: 0;
  overflow: visible;                /* allow scrolling if child overflows */
    }

        /* New: inner scroller so the track sits at far right,
      and does NOT run behind the sticky header */
    .scroller {
      flex: 1 1 auto;
      min-height: 0;
  overflow-y: auto;                 /* always allow vertical scrolling */
      scrollbar-gutter: stable;         /* keeps a gutter so layout doesn’t jump */
      scroll-padding-top: var(--header-h);  /* anchors don’t hide under header */
    }

    header.site-header {
      position: sticky;
      top: 0;
      z-index: 1002;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      height: var(--header-h);     /* ← explicit height */
      background: var(--surface);
      border-bottom: 1px solid var(--border);
    }

    @media (min-width: 901px) {
      .site-header.hide-on-scroll {
        left: 280px; /* sidebar width */
        width: calc(100% - 280px);
      }
      body.sidebar-collapsed .site-header.hide-on-scroll {
        left: 0;
        width: 100%;
      }
    }
    

    /* BUTTONS (theme + arrows share the same style) */
    /* shared style for theme + arrow buttons */
    /* Small circular/square icon buttons used in the header and settings rail.
       Important: these define the hit area (touch target). The actual icon inside
       is sized via --icon-glyph-size so you can make the glyph larger/smaller
       independently of touch size for consistent UX.
    */
    .icon-btn {
      background: none;
      border: 1px solid var(--border);
      border-radius: 10px;
      width: var(--icon-btn-size);
      height: var(--icon-btn-size);
      display: inline-grid;
      place-items: center;
      cursor: pointer;
      color: var(--fg);
      text-decoration: none;
  font-size: 20px;
  line-height: 1;
      padding: 0;
    }

    /* make the numeric line-spacing label smaller and use the reader serif font */
    #s-lineSpacing {
      font-size: 13px; /* slightly smaller than other icons */
      font-family: var(--global-font-family, 'Noto Serif', serif);
      line-height: 1;
      padding: 0;
    }
  /* hyphen toggle small serif label */
  #s-hyphenToggle { font-size: 12px; font-family: var(--global-font-family, 'Noto Serif', serif); }

  /* Remove all button states: no :active, :focus, :hover, or toggled styles. */

    @media (max-width: 900px) {
      /* slightly larger touch targets on phones */
    }

    /* visual size of the svg glyph inside the button; keep glyph smaller than hit area */
    .icon-btn svg { width: var(--icon-glyph-size); height: var(--icon-glyph-size); display: block; }
  /* make the font-cycle button itself use the active reader font so the "F" previews the selection */
  #s-fontCycle { font-family: var(--global-font-family, 'Noto Serif', serif); font-weight: var(--global-font-weight, 400); -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
  /* weight-toggle removed - reclaimed space in settings rail */

    /* Settings sidebar (right) */
    .settings-sidebar {
      position: fixed;
      top: 0;
      right: 0;
      width: var(--settings-rail-w);
      height: 100vh;
      background: var(--surface);
      border-left: 1px solid var(--border);
      box-shadow: -2px 0 12px rgba(0,0,0,0.08);
      display: flex;
      align-items: flex-start;    /* align content to the top */
      justify-content: flex-start;
      z-index: 1100;              /* match left sidebar stacking for consistent overlay ordering */
      transform: translateX(100%);
      transition: transform .25s cubic-bezier(.2,.8,.2,1);
      will-change: transform;     /* hint for smoother animation */
    }
    .settings-sidebar.open { transform: translateX(0); }
    /* Desktop: respect body.settings-open to reveal a compact right rail */
    @media (min-width: 901px) {
      body.settings-open .settings-sidebar { transform: translateX(0); }
      /* reserve a small right margin when settings rail is open so content doesn't shift awkwardly */
  body.settings-open .app { margin-right: var(--settings-rail-w); transition: margin-right .25s cubic-bezier(.2,.8,.2,1); }
    }
    /* place controls centered horizontally and aligned vertically to the header (same level as the cog) */
    .settings-inner {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
    /* position first button so its center lines up with the header center.
      42px is the .icon-btn height; adjust if you change button size
      add a small nudge so the control aligns with the cog distance from the top edge */
    padding-top: 17px;
      align-items: center; /* center horizontally */
      box-sizing: border-box;
    }
  /* reuse icon-btn visuals for cog button; push it to the far right of the tools */
  #cogBtn { display:inline-grid; place-items:center; margin-left: auto; align-self:center; }

    @media (max-width: 900px) {
      .icon-btn svg { width: 22px; height: 22px; }
    }


  /* No hover effect. */

    /* HAMBURGER */
    .menu {
      background: none;
      border: none;
      display: inline-flex;
      flex-direction: column;
      gap: 4px;
      padding: 8px;
      cursor: pointer;
    }
    .menu span {
      width: 24px;
      height: 2.5px;
      background: var(--fg);
      border-radius: 2px;
      transition: background .2s ease;
    }

    .tools {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    main.reader {
      flex: 0 0 auto;
      overflow: visible;
      box-sizing: border-box;
      max-width: var(--content-w);                  /* your readable width */
      margin: 0 auto;
      padding: 0px 16px 40px;           /* small top pad so text doesn’t kiss border */
    }
    @media (min-width: 901px){
      main.reader{ padding: 0 24px 56px; }
    }


    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin: 10px 0 18px;
    }

  article#article {
    font-size: 18px;
    font-family: var(--global-font-family, 'Noto Serif', serif);
  font-weight: var(--global-font-weight, 400);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    /* Justify body copy for a book-like reading experience */
    text-align: justify;
    text-justify: inter-word;
    -webkit-hyphens: auto;
    -moz-hyphens: auto;
    hyphens: auto;
    /* allow long words to break if needed */
    overflow-wrap: anywhere;
  }

  /* ensure sidebar h1 and header chapter title remain bold regardless of global weight */
  .sidebar h1, #chapterTitle { font-weight: 700; }
    article#article h1, article#article h2, article#article h3 {
      line-height: 1.25;
      margin-top: 1.4em;
      /* keep headings left-aligned so they don't center with justified body text */
      text-align: left;
    }
  article#article p { margin: 1em 0; }
  /* paragraph indent support when user enables it (applies to article paragraphs) */
  .para-indent article#article p { text-indent: 1.25em; }
    article#article hr {
      border: 0;
      border-top: 1px solid var(--border);
      margin: 2rem 0;
    }
    article#article a { color: var(--link); }

    /* OVERLAY for mobile only */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.45);
      display: none;
      z-index: 1095; /* below sidebars (1100) */
    }
    .overlay.show { display: block; }

    /* MOBILE */
    @media (max-width: 900px) {
      .app { grid-template-columns: 1fr; }          /* sidebar column hidden */

      .sidebar{
        position: fixed;
        left: 0; top: 0; bottom: 0;
        transform: translateX(-100%);
        transition: transform .25s ease;
        width: min(85vw, 320px);
        z-index: 1100;                               /* above page header */
        background: var(--surface);
        border-right: 1px solid var(--border);
        overflow-y: auto;                             /* drawer scrolls */
        padding-top: 0px;  /* space from top */
      }
      .sidebar.open{ transform: translateX(0); }

      /* Simple title — centered, no sticky */
      .sidebar h1{
        text-align:center;
        margin: 16px 0 10px;
        padding: 0px 16px;
        text-align: center;
        font-size: 18px;
        font-weight: 700;
      }

      /* List sits right under the title */
      .sidebar ul{
        margin: 0;
        padding: 0;
      }

      /* overlay sits below drawer but above content */
      .overlay{ z-index: 1090; }
  /* settings sidebar mobile alignment */
  .settings-sidebar { top: 0; padding-top: 0px; z-index: 1100; }
  .settings-sidebar.open { transform: translateX(0); }
    }


  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar" id="sidebar">
      <h1>Martial Peak</h1>
      <div class="chapter-search-wrap">
        <input id="chapterSearch" class="chapter-search" type="text" placeholder="Search chapters…" aria-label="Search chapters">
        <button id="chapterSearchClear" class="chapter-search-clear" aria-label="Clear search">✕</button>
      </div>
  <div id="chaptersNoResults" class="no-results hidden" aria-live="polite"></div>
      <ul class="chapter-list" id="chaptersList"></ul>
    </aside>

    <div class="content">
      <!--
        Header: contains the hamburger menu, current chapter title, and header tools.
        - #menuBtn toggles the left chapter drawer (mobile) or collapses the sidebar (desktop)
        - #chapterTitle shows the current chapter's title
        - .tools holds inline header controls (arrows + cog). Most controls are shared
          with the right settings rail to keep behavior consistent.
      -->
      <header class="site-header">
        <button class="menu" id="menuBtn" aria-label="Menu">
          <span></span><span></span><span></span>
        </button>
        <strong id="chapterTitle">Loading…</strong>
  <div class="tools">
          <!-- font and theme controls moved into the settings sidebar on the right -->
          <button id="themeBtn" class="icon-btn" title="Toggle theme" aria-label="Toggle theme">🌓</button>
          <!-- top nav arrows (these are buttons for consistent semantics/accessibility) -->
          <button id="prevTop" class="icon-btn hidden" aria-label="Previous">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
          </button>
          <button id="nextTop" class="icon-btn hidden" aria-label="Next">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </button>
          <button id="cogBtn" class="icon-btn" title="Settings" aria-label="Settings">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33h.09A1.65 1.65 0 0 0 11 3.09V3a2 2 0 0 1 4 0v.09c.38.16.7.46 1 1.51a1.65 1.65 0 0 0 1.82.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82c.16.38.46.7 1.51 1H21a2 2 0 0 1 0 4h-.09c-.16.38-.46.7-1.51 1z"></path></svg>
          </button>
        </div>
      </header>

      <div class="scroller">
        <main class="reader">
          <nav class="nav" id="topNav" style="display:none;"></nav> <!-- kept for structure -->
          <article id="article"></article>
          <nav class="nav" id="bottomNav">
            <button id="prevBottom" class="icon-btn hidden" aria-label="Previous">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <polyline points="15 18 9 12 15 6"></polyline>
              </svg>
            </button>
            <button id="nextBottom" class="icon-btn hidden" aria-label="Next">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <polyline points="9 18 15 12 9 6"></polyline>
              </svg>
            </button>
          </nav>
          <!-- Comments -->
          <div id="giscusContainer" style="margin-top:24px;"></div>
        </main>
      </div>
    </div>
  </div>
  <aside class="settings-sidebar" id="settingsSidebar" aria-hidden="true">
    <!--
      Right settings rail: compact vertical controls for font + theme.
      - Sits off-canvas on mobile and as a compact rail on desktop when body.settings-open
      - Buttons here invoke the same handlers as header controls (reuse behavior)
    -->
    <div class="settings-inner" role="menu" aria-label="Settings">
      <button id="s-themeBtn" class="icon-btn" title="Toggle theme" aria-label="Toggle theme">🌓</button>
  <button id="s-fontInc" class="icon-btn" title="Increase font size" aria-label="Increase font size">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
      </button>
      <button id="s-fontDec" class="icon-btn" title="Decrease font size" aria-label="Decrease font size">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
      </button>
      <!-- Cycle reader font family: Droid Serif ↔ Helvetica -->
      <button id="s-fontCycle" class="icon-btn" title="Cycle font family" aria-label="Cycle font family">F</button>
  <!-- font-weight toggle removed to save space -->

      <!-- Text alignment toggle: cycles justify | left | center | right -->
      <button id="s-alignToggle" class="icon-btn" title="Text align: Justify" aria-label="Text align: Justify">
        <!-- default icon (will be replaced on load) -->
        <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="4" y1="6" x2="20" y2="6"></line>
          <line x1="4" y1="10" x2="20" y2="10"></line>
          <line x1="4" y1="14" x2="20" y2="14"></line>
          <line x1="4" y1="18" x2="20" y2="18"></line>
        </svg>
      </button>

      <!-- Paragraph indent toggle: toggles first-line indent on/off -->
      <button id="s-indentToggle" class="icon-btn" title="Paragraph indent: Off" aria-label="Paragraph indent: Off">
        <!-- default icon (updated by JS) -->
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="4" y1="6" x2="20" y2="6"></line>
          <line x1="4" y1="10" x2="20" y2="10"></line>
          <line x1="4" y1="14" x2="20" y2="14"></line>
        </svg>
      </button>

      <!-- Line spacing toggle: cycles 1.0 | 1.1 | 1.2 | 1.3 | 1.4 | 1.5 -->
  <button id="s-lineSpacing" class="icon-btn" title="Line spacing: 1.2" aria-label="Line spacing: 1.2">1.2</button>
  <!-- Hyphenation toggle: toggles hyphens on/off for the article -->
  <button id="s-hyphenToggle" class="icon-btn" title="Hyphenation: On" aria-label="Hyphenation: On">Hy</button>

  <!-- Content-width controls: narrow / widen readable column -->
  <button id="s-contentInc" class="icon-btn" title="Widen column" aria-label="Widen column">
    <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <!-- left arrow pointing left -->
      <polyline points="10 6, 4 12, 10 18"></polyline>
      <!-- right arrow pointing right -->
      <polyline points="14 6, 20 12, 14 18"></polyline>
    </svg>
  </button>

  
  <button id="s-contentDec" class="icon-btn" title="Narrow column" aria-label="Narrow column">
    <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <!-- left arrow pointing right -->
      <polyline points="4 6, 10 12, 4 18"></polyline>
      <!-- right arrow pointing left -->
      <polyline points="20 6, 14 12, 20 18"></polyline>
    </svg>
  </button>

  <!-- Reset settings (keeps current theme) -->
  <button id="s-reset" class="icon-btn" title="Reset settings" aria-label="Reset settings">↺</button>


      </div>
  
  </aside>

  <div class="overlay" id="overlay"></div>

  <script>
  // ====== Small runtime guide ======
  // This script wires UI controls (menu, cog, font/theme, navigation) to shared helper
  // functions. Key persisted keys in localStorage are:
  //  - mp_theme: 'white' | 'light' | 'dark' | 'black'
  //  - mp_fontsize: number (px)

  // --- Theme ---
    const THEME_ORDER = ['white', 'light', 'dark', 'black'];
    const THEME_ICON = { white: '❄️', light: '☀️', dark: '🌙', black: '🌑' };
    function setTheme(mode) {
      document.documentElement.setAttribute('data-theme', mode);
      localStorage.setItem('mp_theme', mode);
      // update any theme buttons if present (header or sidebar)
      const headerThemeBtn = document.getElementById('themeBtn');
      const sidebarThemeBtn = document.getElementById('s-themeBtn');
      const label = THEME_ICON[mode] || '�';
      if (headerThemeBtn) headerThemeBtn.textContent = label;
      if (sidebarThemeBtn) sidebarThemeBtn.textContent = label;
      if (headerThemeBtn) { headerThemeBtn.title = `Theme: ${mode}`; headerThemeBtn.setAttribute('aria-label', `Theme: ${mode}`); }
      if (sidebarThemeBtn) { sidebarThemeBtn.title = `Theme: ${mode}`; sidebarThemeBtn.setAttribute('aria-label', `Theme: ${mode}`); }
  // sync Giscus theme if present
  try { updateGiscusTheme(mode); } catch (_) {}
    }
  // Ensure sensible defaults on first run so the reader opens with these settings
  if (!localStorage.getItem('mp_theme')) localStorage.setItem('mp_theme', 'light');
  if (!localStorage.getItem('mp_textAlign')) localStorage.setItem('mp_textAlign', 'justify');
  if (!localStorage.getItem('mp_readerFont')) localStorage.setItem('mp_readerFont', 'noto-serif');
  if (!localStorage.getItem('mp_paraIndent')) localStorage.setItem('mp_paraIndent', '1');
  if (!localStorage.getItem('mp_fontsize')) localStorage.setItem('mp_fontsize', '20');
  if (!localStorage.getItem('mp_contentw')) localStorage.setItem('mp_contentw', '68');
  // reader weight toggle removed; keep default typography consistent via --global-font-weight
  if (!localStorage.getItem('mp_lineHeight')) localStorage.setItem('mp_lineHeight', '1.3');
  // apply theme from storage (now present)
  setTheme(localStorage.getItem('mp_theme'));
  // ensure CSS variable for global font weight defaults to 400 on first run
  if (!localStorage.getItem('mp_readerWeight')) {
    document.documentElement.style.setProperty('--global-font-weight', '400');
  }

  // Font size controls
  // Note: There are two places for font controls — header (optional) and settings rail.
  // We wire both to the same handlers so behavior is identical.
  const fontInc = document.getElementById('fontInc');
  const fontDec = document.getElementById('fontDec');
  const sFontInc = document.getElementById('s-fontInc');
  const sFontDec = document.getElementById('s-fontDec');
  const sReset = document.getElementById('s-reset');
  const article = document.getElementById('article');
    function getFontSize() {
      return parseFloat(window.getComputedStyle(article).fontSize);
    }
    function setFontSize(size) {
      article.style.fontSize = size + 'px';
      localStorage.setItem('mp_fontsize', size);
    }
    if (fontInc) {
      fontInc.addEventListener('click', () => {
        setFontSize(Math.min(getFontSize() + 2, 36));
      });
    }
    if (fontDec) {
      fontDec.addEventListener('click', () => {
        setFontSize(Math.max(getFontSize() - 2, 12));
      });
    }
  if (sFontInc) sFontInc.addEventListener('click', () => setFontSize(Math.min(getFontSize() + 2, 36)));
  if (sFontDec) sFontDec.addEventListener('click', () => setFontSize(Math.max(getFontSize() - 2, 12)));
    // Load saved font size
    const savedFont = localStorage.getItem('mp_fontsize');
    if (savedFont) setFontSize(parseFloat(savedFont));
    const headerThemeBtn = document.getElementById('themeBtn');
    function cycleTheme() {
      const current = localStorage.getItem('mp_theme') || 'light';
      const idx = THEME_ORDER.indexOf(current);
      const next = THEME_ORDER[(idx >= 0 ? idx + 1 : 0) % THEME_ORDER.length];
      setTheme(next);
    }
    if (headerThemeBtn) headerThemeBtn.addEventListener('click', cycleTheme);

  // --- Reader font family cycling ---
  const sFontCycle = document.getElementById('s-fontCycle');
  const READER_FONTS = [
    { id: 'noto-serif', name: 'Noto Serif', css: "'Noto Serif', serif" },
    { id: 'noto-sans', name: 'Noto Sans', css: "'Noto Sans', sans-serif" }
  ];
  const DEFAULT_READER_ID = 'noto-serif';
  function applyReaderFontById(id) {
    const f = READER_FONTS.find(x => x.id === id) || READER_FONTS[0];
  // set the global font family token so the whole UI follows
  document.documentElement.style.setProperty('--global-font-family', f.css);
    localStorage.setItem('mp_readerFont', f.id);
    const lbl = document.getElementById('s-contentLabel');
  // show font name and content width; weight toggle removed
  if (lbl) lbl.textContent = f.name + ' • ' + getContentWCh() + 'ch';
  }
  function cycleReaderFont() {
    const curId = localStorage.getItem('mp_readerFont') || DEFAULT_READER_ID;
    const idx = Math.max(0, READER_FONTS.findIndex(f => f.id === curId));
    const next = READER_FONTS[(idx + 1) % READER_FONTS.length];
    applyReaderFontById(next.id);
  }
  if (sFontCycle) sFontCycle.addEventListener('click', cycleReaderFont);
  // Restore saved reader font on load (use id-based storage)
  const savedReaderFontId = localStorage.getItem('mp_readerFont');
  if (savedReaderFontId) applyReaderFontById(savedReaderFontId);
  else applyReaderFontById(DEFAULT_READER_ID);

  // --- Reset settings (except theme) ---
  function resetSettingsExceptTheme() {
    const theme = localStorage.getItem('mp_theme') || 'light';
    // Clear all but keep theme value
    try {
      localStorage.clear();
    } catch (_) {}
    // Reapply defaults
    localStorage.setItem('mp_theme', theme);
    localStorage.setItem('mp_textAlign', 'justify');
    localStorage.setItem('mp_readerFont', DEFAULT_READER_ID);
    localStorage.setItem('mp_paraIndent', '1');
    localStorage.setItem('mp_fontsize', '20');
    localStorage.setItem('mp_contentw', '68');
    localStorage.setItem('mp_lineHeight', '1.3');
    // Re-apply UI state
    setTheme(theme);
    applyReaderFontById(DEFAULT_READER_ID);
    setFontSize(parseFloat(localStorage.getItem('mp_fontsize')));
    applyAlignment(localStorage.getItem('mp_textAlign'));
    applyParaIndent(!!localStorage.getItem('mp_paraIndent'));
    const savedLine = parseFloat(localStorage.getItem('mp_lineHeight') || '1.2');
    applyLineSpacing(isNaN(savedLine) ? 1.2 : savedLine);
    const savedContentW = localStorage.getItem('mp_contentw');
    if (savedContentW) setContentWCh(parseFloat(savedContentW));
  }
  if (sReset) sReset.addEventListener('click', resetSettingsExceptTheme);

  // reader font weight toggle removed (no longer used)

  // --- Sidebar open/close ---
  // Elements that control drawers/overlays. The code distinguishes mobile vs desktop
  // behavior: mobile uses slide + overlay; desktop toggles compact columns without overlay.
  const sidebar = document.getElementById('sidebar');
  const overlay = document.getElementById('overlay');
  const menuBtn = document.getElementById('menuBtn');
  const cogBtn = document.getElementById('cogBtn');
  const settingsSidebar = document.getElementById('settingsSidebar');
  const sThemeBtn = document.getElementById('s-themeBtn');
  const isMobile = () => window.matchMedia('(max-width: 900px)').matches;

    function openSidebarMobile(){ sidebar.classList.add('open'); overlay.classList.add('show'); }
    function closeSidebarMobile(){ sidebar.classList.remove('open'); overlay.classList.remove('show'); }

  function openSettingsMobile(){ settingsSidebar.classList.add('open'); overlay.classList.add('show'); settingsSidebar.setAttribute('aria-hidden','false'); }
  function closeSettingsMobile(){ settingsSidebar.classList.remove('open'); overlay.classList.remove('show'); settingsSidebar.setAttribute('aria-hidden','true'); }

    menuBtn.addEventListener('click', () => {
      if (isMobile()) {
        // mobile: slide drawer with overlay
        sidebar.classList.contains('open') ? closeSidebarMobile() : openSidebarMobile();
      } else {
        // desktop: collapse/expand sidebar; NEVER show overlay on desktop
        document.body.classList.toggle('sidebar-collapsed');
        overlay.classList.remove('show');
      }
    });
    overlay.addEventListener('click', () => { closeSidebarMobile(); closeSettingsMobile(); });
    window.addEventListener('resize', () => { if (!isMobile()) overlay.classList.remove('show'); });

    // cog button — toggles right settings drawer (mirror of hamburger but on the right)
    if (cogBtn) {
      cogBtn.addEventListener('click', () => {
        if (isMobile()) {
          settingsSidebar.classList.contains('open') ? closeSettingsMobile() : openSettingsMobile();
        } else {
          // desktop: toggle a class to show/hide the settings column (no overlay on desktop)
          document.body.classList.toggle('settings-open');
        }
      });
    }

    // wire the small sidebar theme button to the same theme toggler
  if (sThemeBtn) { sThemeBtn.addEventListener('click', cycleTheme); }

    // --- Content-width controls (readable column width) ---
    const sContentInc = document.getElementById('s-contentInc');
    const sContentDec = document.getElementById('s-contentDec');
    const sContentLabel = document.getElementById('s-contentLabel');

    function getContentWCh() {
      const raw = getComputedStyle(document.documentElement).getPropertyValue('--content-w') || '72ch';
      return parseFloat(raw);
    }
    function pxPerCh() {
      // measure 1ch in pixels reliably (accounts for current font)
      const el = document.createElement('span');
      el.style.position = 'absolute';
      el.style.visibility = 'hidden';
      el.style.width = '1ch';
      el.style.font = getComputedStyle(document.documentElement).font;
      document.body.appendChild(el);
      const w = el.getBoundingClientRect().width || el.offsetWidth || 8;
      document.body.removeChild(el);
      return w;
    }

    // --- Text alignment toggle (justify | left | center | right) ---
    const sAlignToggle = document.getElementById('s-alignToggle');
    const ALIGN_MODES = ['justify','left','center','right'];
    const ALIGN_ICONS = {
      justify: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="6" x2="20" y2="6"></line><line x1="4" y1="10" x2="20" y2="10"></line><line x1="4" y1="14" x2="20" y2="14"></line><line x1="4" y1="18" x2="20" y2="18"></line></svg>',
      left: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="6" x2="12" y2="6"></line><line x1="4" y1="10" x2="16" y2="10"></line><line x1="4" y1="14" x2="12" y2="14"></line><line x1="4" y1="18" x2="16" y2="18"></line></svg>',
      center: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="6" x2="18" y2="6"></line><line x1="8" y1="10" x2="16" y2="10"></line><line x1="6" y1="14" x2="18" y2="14"></line><line x1="8" y1="18" x2="16" y2="18"></line></svg>',
      right: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="6" x2="20" y2="6"></line><line x1="8" y1="10" x2="20" y2="10"></line><line x1="12" y1="14" x2="20" y2="14"></line><line x1="8" y1="18" x2="20" y2="18"></line></svg>'
    };

    function applyAlignment(mode) {
      if (!mode) mode = 'justify';
      mode = ALIGN_MODES.includes(mode) ? mode : 'justify';
      // apply to article
      article.style.textAlign = mode === 'justify' ? 'justify' : mode;
      // store for persistence
      localStorage.setItem('mp_textAlign', mode);
      // update the toggle icon/title
      if (sAlignToggle) {
        sAlignToggle.innerHTML = ALIGN_ICONS[mode] || ALIGN_ICONS.justify;
        sAlignToggle.title = 'Text align: ' + mode.charAt(0).toUpperCase() + mode.slice(1);
        sAlignToggle.setAttribute('aria-label', 'Text align: ' + mode);
      }
    }

    function cycleAlignment() {
      const cur = localStorage.getItem('mp_textAlign') || 'justify';
      const idx = Math.max(0, ALIGN_MODES.indexOf(cur));
      const next = ALIGN_MODES[(idx + 1) % ALIGN_MODES.length];
      applyAlignment(next);
    }

    if (sAlignToggle) sAlignToggle.addEventListener('click', cycleAlignment);
    // restore saved alignment on load
    const savedAlign = localStorage.getItem('mp_textAlign') || 'justify';
    applyAlignment(savedAlign);

    // --- Paragraph indent toggle ---
    const sIndentToggle = document.getElementById('s-indentToggle');
    const INDENT_ICON = {
      on: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="6" width="4" height="12" rx="1"></rect><line x1="11" y1="10" x2="21" y2="10"></line><line x1="11" y1="14" x2="21" y2="14"></line></svg>',
      off: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="8" x2="20" y2="8"></line><line x1="4" y1="12" x2="20" y2="12"></line><line x1="4" y1="16" x2="20" y2="16"></line></svg>'
    };

    function applyParaIndent(enabled) {
      const on = Boolean(enabled);
      if (on) {
        // add a class so CSS can style first-line indent
        document.documentElement.classList.add('para-indent');
        localStorage.setItem('mp_paraIndent', '1');
      } else {
        document.documentElement.classList.remove('para-indent');
        localStorage.removeItem('mp_paraIndent');
      }
      if (sIndentToggle) {
        sIndentToggle.innerHTML = on ? INDENT_ICON.on : INDENT_ICON.off;
        sIndentToggle.title = 'Paragraph indent: ' + (on ? 'On' : 'Off');
        sIndentToggle.setAttribute('aria-label', 'Paragraph indent: ' + (on ? 'On' : 'Off'));
      }
    }

    function toggleParaIndent() {
      const cur = !!localStorage.getItem('mp_paraIndent');
      applyParaIndent(!cur);
    }

    if (sIndentToggle) sIndentToggle.addEventListener('click', toggleParaIndent);
    // restore saved indent state
    const savedIndent = !!localStorage.getItem('mp_paraIndent');
    applyParaIndent(savedIndent);

    // --- Line spacing toggle (1.0 -> 1.1 -> 1.2 -> 1.3 -> 1.4 -> 1.5) ---
    const sLineSpacing = document.getElementById('s-lineSpacing');
  const LINE_SPACES = [1.2, 1.3, 1.4, 1.5];

    function applyLineSpacing(val) {
      let v = Number(val) || 1.2;
      // normalize to one of the supported steps
      if (!LINE_SPACES.includes(v)) {
        // find nearest
        v = LINE_SPACES.reduce((prev, curr) => Math.abs(curr - v) < Math.abs(prev - v) ? curr : prev, LINE_SPACES[0]);
      }
      article.style.lineHeight = String(v);
      localStorage.setItem('mp_lineHeight', String(v));
      if (sLineSpacing) {
        sLineSpacing.textContent = String(v);
        sLineSpacing.title = 'Line spacing: ' + v;
        sLineSpacing.setAttribute('aria-label', 'Line spacing: ' + v);
      }
    }

    function cycleLineSpacing() {
      const cur = parseFloat(localStorage.getItem('mp_lineHeight') || '1.2');
      const idx = Math.max(0, LINE_SPACES.findIndex(x => Math.abs(x - cur) < 0.001));
      const next = LINE_SPACES[(idx + 1) % LINE_SPACES.length];
      applyLineSpacing(next);
    }

    if (sLineSpacing) sLineSpacing.addEventListener('click', cycleLineSpacing);
    // restore saved line-height or default to 1.2
  const savedLine = parseFloat(localStorage.getItem('mp_lineHeight') || '1.2');
  applyLineSpacing(isNaN(savedLine) ? 1.2 : savedLine);

    // --- Hyphenation toggle ---
    const sHyphenToggle = document.getElementById('s-hyphenToggle');
    function applyHyphens(enabled) {
      const on = Boolean(enabled);
      if (on) {
        article.style.hyphens = 'auto';
        document.documentElement.classList.add('hyphens-on');
        localStorage.setItem('mp_hyphens', '1');
      } else {
        article.style.hyphens = 'none';
        document.documentElement.classList.remove('hyphens-on');
        localStorage.removeItem('mp_hyphens');
      }
      if (sHyphenToggle) {
        sHyphenToggle.textContent = 'Hy';
        sHyphenToggle.title = 'Hyphenation: ' + (on ? 'On' : 'Off');
        sHyphenToggle.setAttribute('aria-label', 'Hyphenation: ' + (on ? 'On' : 'Off'));
      }
    }
    function toggleHyphens() { applyHyphens(!!localStorage.getItem('mp_hyphens') ? false : true); }
    if (sHyphenToggle) sHyphenToggle.addEventListener('click', toggleHyphens);
    // restore hyphenation state
    applyHyphens(!!localStorage.getItem('mp_hyphens'));

    function viewportChAvailable() {
      const chPx = pxPerCh();
      const reader = document.querySelector('main.reader');
      let padLeft = 0, padRight = 0;
      if (reader) {
        const cs = getComputedStyle(reader);
        padLeft = parseFloat(cs.paddingLeft) || 0;
        padRight = parseFloat(cs.paddingRight) || 0;
      }
      const availablePx = Math.max(0, window.innerWidth - padLeft - padRight);
      return Math.max(1, Math.floor(availablePx / chPx));
    }

    function setContentWCh(n) {
      const clamped = Math.max(20, Math.min(n, 240)); // bounds in ch
      const avail = viewportChAvailable();
      const applied = Math.min(clamped, avail);
      document.documentElement.style.setProperty('--content-w', applied + 'ch');
      localStorage.setItem('mp_contentw', String(applied));
      if (sContentLabel) sContentLabel.textContent = applied + 'ch';
    }
    if (sContentInc) sContentInc.addEventListener('click', () => setContentWCh(getContentWCh() + 4));
    if (sContentDec) sContentDec.addEventListener('click', () => setContentWCh(getContentWCh() - 4));
    // restore saved content width
    const savedContentW = localStorage.getItem('mp_contentw');
    if (savedContentW) setContentWCh(parseFloat(savedContentW));
    else if (sContentLabel) sContentLabel.textContent = getContentWCh() + 'ch';
    // Adjust content width if viewport shrinks smaller than current setting
    window.addEventListener('resize', () => {
      try {
        const avail = viewportChAvailable();
        const current = getContentWCh();
        if (current > avail) setContentWCh(avail);
        else if (sContentLabel) sContentLabel.textContent = current + 'ch';
      } catch (e) { /* noop */ }
    });

  // --- Helpers ---
  // Short helper for querying elements and named references used below.
  const qs = (sel) => document.querySelector(sel);
  const titleEl = qs('#chapterTitle');
  const chaptersListEl = qs('#chaptersList');
  const chapterSearchEl = qs('#chapterSearch');
  const articleEl = qs('#article');
  const scrollerEl = document.querySelector('.scroller');


    // Navigation button refs (top header and bottom nav share the same handlers)
    const navEls = {
      prevTop: qs('#prevTop'),
      nextTop: qs('#nextTop'),
      prevBottom: qs('#prevBottom'),
      nextBottom: qs('#nextBottom'),
    };

    function getParam(name) {
      const url = new URL(window.location.href);
      return url.searchParams.get(name);
    }
    function setParam(name, value) {
      const url = new URL(window.location.href);
      if (value == null) url.searchParams.delete(name);
      else url.searchParams.set(name, value);
      history.pushState({}, '', url);
    }
    function normalizeId(id) {
      if (!id) return id;
      return id.endsWith('.md') ? id.slice(0, -3) : id;
    }

    // --- External chapters support (fetch from other repos) ---
    // Allow specifying a novel by key (?novel=martial-peak) or an explicit repo (?repo=courting-death/martial-peak)
    // Optional branch via ?branch=<name> (defaults to main).
    const OWNER = 'courting-death';
    const NOVEL_MAP = {
      'martial-peak': 'martial-peak'
    };

    // Per-novel Discussions (ID-based) used by Giscus
    // Fill this with repo/category IDs per novel repository.
    const NOVEL_DISCUSSIONS = {
      'courting-death/martial-peak': {
        repoId: 'R_kgDOPgGOOA',
        category: 'Chapters',
        categoryId: 'DIC_kwDOPgGOOM4CuUCY'
      }
    };

    const qpNovel  = getParam('novel');
    const qpRepo   = getParam('repo');
    const qpBranch = getParam('branch') || 'main';

    function resolveRepoRef() {
      if (qpRepo) {
        const [owner, repo] = qpRepo.split('/');
        if (owner && repo) return { owner, repo, branch: qpBranch };
      }
      if (qpNovel && NOVEL_MAP[qpNovel]) {
        return { owner: OWNER, repo: NOVEL_MAP[qpNovel], branch: qpBranch };
      }
      return null; // use local chapters folder
    }

    function buildChapterURLs() {
      const ref = resolveRepoRef();
      if (!ref) {
        return {
          baseIndex: 'chapters/chapters.json',
          chapterURL: (id) => `chapters/${id}.md`,
        };
      }
      const { owner, repo, branch } = ref;
      const base = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/chapters`;
      return {
        baseIndex: `${base}/chapters.json`,
        chapterURL: (id) => `${base}/${id}.md`,
      };
    }

    // Build href for chapter links while preserving existing query params (novel/repo/branch)
    function buildChapterHref(id) {
      const url = new URL(window.location.href);
      if (id == null) url.searchParams.delete('chapter');
      else url.searchParams.set('chapter', id);
      return `${url.pathname}?${url.searchParams.toString()}`;
    }

    // Human label for current novel/repo to use in titles/headers
    function toTitleCase(s) { return (s || '').replace(/[-_]+/g, ' ').replace(/\b\w/g, c => c.toUpperCase()); }
    function currentNovelLabel() {
      if (qpRepo) {
        const parts = qpRepo.split('/');
        return toTitleCase(parts[1] || qpRepo);
      }
      if (qpNovel) return toTitleCase(qpNovel);
      // fallback to existing hard-coded label
      return 'Martial Peak';
    }

    // ====== Giscus helpers ======
    function currentRepoKey() {
      const ref = resolveRepoRef();
      return ref ? `${ref.owner}/${ref.repo}` : null;
    }
    function currentChapterId() {
      return (CHAPTERS[currentIndex] && CHAPTERS[currentIndex].id) || null;
    }
  // Map site themes to Giscus built-in themes
    function giscusThemeFor(mode) {
      // giscus supports 'light' and 'dark' built-ins; map our white->light, light->light, dark->dark, black->dark
      if (mode === 'dark') return 'dark';
      if (mode === 'black') return 'dark_protanopia';
      if (mode === 'light') return 'light';
      if (mode === 'white') return 'light_protanopia';
    }
    function updateGiscusTheme(mode) {
      const iframe = document.querySelector('iframe.giscus-frame');
      if (!iframe) return;
      iframe.contentWindow.postMessage({ giscus: { setConfig: { theme: giscusThemeFor(mode) } } }, 'https://giscus.app');
    }
    function renderGiscus() {
      const container = document.getElementById('giscusContainer');
      if (!container) return;
      const repoKey = currentRepoKey();
      const chap = currentChapterId();
      if (!repoKey || !chap) { container.innerHTML = ''; return; }
  const term = `${repoKey}:${chap}`;

      // clear previous instance and inject a fresh script
      container.innerHTML = '';
      const s = document.createElement('script');
      s.src = 'https://giscus.app/client.js';
      s.async = true;
      s.crossOrigin = 'anonymous';
      s.setAttribute('data-repo', repoKey);
      const conf = NOVEL_DISCUSSIONS[repoKey] || {};
      if (conf.repoId) s.setAttribute('data-repo-id', conf.repoId);
      s.setAttribute('data-category', conf.category || 'Chapters');
      if (conf.categoryId) s.setAttribute('data-category-id', conf.categoryId);
      s.setAttribute('data-mapping', 'specific');
      s.setAttribute('data-term', term);
      s.setAttribute('data-strict', '1');
      s.setAttribute('data-reactions-enabled', '1');
      s.setAttribute('data-emit-metadata', '0');
      s.setAttribute('data-input-position', 'top');
      s.setAttribute('data-theme', giscusThemeFor(localStorage.getItem('mp_theme') || 'light'));
      s.setAttribute('data-lang', 'en');
      s.setAttribute('data-loading', 'eager');
      container.appendChild(s);
    }

    // Defer Giscus rendering so comments load after the chapter content
    let giscusTimeoutId = null;
    let giscusIdleId = null;
    function cancelScheduledGiscus() {
      if (giscusTimeoutId) { clearTimeout(giscusTimeoutId); giscusTimeoutId = null; }
      if (giscusIdleId && 'cancelIdleCallback' in window) { cancelIdleCallback(giscusIdleId); giscusIdleId = null; }
    }
    function scheduleGiscusRender(delayMs = 800) {
      cancelScheduledGiscus();
      const run = () => { giscusTimeoutId = null; giscusIdleId = null; try { renderGiscus(); } catch (_) {} };
      if ('requestIdleCallback' in window) {
        giscusIdleId = requestIdleCallback(run, { timeout: delayMs + 200 });
        giscusTimeoutId = setTimeout(() => { if (giscusIdleId) { cancelIdleCallback(giscusIdleId); giscusIdleId = null; } run(); }, delayMs);
      } else {
        giscusTimeoutId = setTimeout(run, delayMs);
      }
    }

    // --- Load chapters index ---
    let CHAPTERS = [];        // [{ id, title }]
    let currentIndex = -1;    // index in CHAPTERS

    async function loadIndex() {
      const urls = buildChapterURLs();
      try {
        const res = await fetch(urls.baseIndex, { cache: 'no-cache' });
        CHAPTERS = await res.json();
      } catch (e) {
        console.error('Failed to load chapters.json', e);
        CHAPTERS = [];
      }
      renderList();
    }

    // --- Chapter search: live filter the rendered list ---
    function applyChapterFilter() {
      renderList();
      // keep active highlight in sync
      highlightActive();
    }
    if (chapterSearchEl) {
      const chapterSearchClear = document.getElementById('chapterSearchClear');
      const updateClearVisibility = () => {
        if (!chapterSearchClear) return;
        if (chapterSearchEl.value && chapterSearchEl.value.trim().length) chapterSearchClear.classList.remove('hidden');
        else chapterSearchClear.classList.add('hidden');
      };
      // initialize clear button visibility
      updateClearVisibility();
      if (chapterSearchClear) chapterSearchClear.addEventListener('click', (ev) => {
        ev.preventDefault();
        chapterSearchEl.value = '';
        updateClearVisibility();
        applyChapterFilter();
        chapterSearchEl.focus();
      });
      chapterSearchEl.addEventListener('input', (e) => {
        updateClearVisibility();
        applyChapterFilter();
      });
      chapterSearchEl.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
          // open first visible match
          const first = chaptersListEl.querySelector('a');
          if (first) {
            ev.preventDefault();
            const params = new URL(first.href).searchParams;
            const id = params.get('chapter');
            if (id) openChapterById(id);
            if (isMobile()) closeSidebarMobile();
          }
        } else if (ev.key === 'Escape') {
          chapterSearchEl.value = '';
          applyChapterFilter();
        }
      });
    }

    function renderList() {
      // If a search query exists, filter CHAPTERS by title/id
      const q = (chapterSearchEl && chapterSearchEl.value) ? chapterSearchEl.value.trim().toLowerCase() : '';
      const list = q ? CHAPTERS.filter(c => ((c.title || c.id) + '').toLowerCase().includes(q)) : CHAPTERS;
      chaptersListEl.innerHTML = '';
      const noResultsEl = document.getElementById('chaptersNoResults');
      if (!list || list.length === 0) {
        if (noResultsEl) {
          const rawQ = chapterSearchEl && chapterSearchEl.value ? chapterSearchEl.value.trim() : '';
          if (CHAPTERS.length === 0) noResultsEl.textContent = 'No chapters available';
          else if (rawQ) noResultsEl.textContent = `No results`;
          else noResultsEl.textContent = 'No chapters';
          noResultsEl.classList.remove('hidden');
        }
        return;
      }
      if (noResultsEl) noResultsEl.classList.add('hidden');
      list.forEach((c, visibleIndex) => {
        // find original index in CHAPTERS so opening uses correct index
        const i = CHAPTERS.findIndex(x => x.id === c.id);
        const li = document.createElement('li');
  const a = document.createElement('a');
  a.href = buildChapterHref(c.id);
        a.textContent = c.title || c.id;
        a.addEventListener('click', (ev) => {
          ev.preventDefault();
          openChapterByIndex(i);
          if (isMobile()) closeSidebarMobile();
        });
        li.appendChild(a);
        chaptersListEl.appendChild(li);
      });
    }

    function highlightActive() {
      const links = Array.from(chaptersListEl.querySelectorAll('a'));
      links.forEach((a) => {
        // extract chapter id from href and compare to CHAPTERS[currentIndex].id
        const href = a.getAttribute('href') || '';
        const params = new URL(href, location.origin).searchParams;
        const id = params.get('chapter');
        const isActive = (currentIndex >= 0 && CHAPTERS[currentIndex] && CHAPTERS[currentIndex].id === id);
        a.classList.toggle('active', isActive);
      });
    }

    async function openChapterById(id) {
      const norm = normalizeId(id);
      const index = CHAPTERS.findIndex(c => c.id === norm);
      if (index === -1 && CHAPTERS.length > 0) return openChapterByIndex(0);
      return openChapterByIndex(index);
    }

    async function openChapterByIndex(i) {
      if (i < 0 || i >= CHAPTERS.length) return;
      currentIndex = i;
  const { id, title } = CHAPTERS[i];
  titleEl.textContent = title || id;
  document.title = (title || id) + ' — ' + currentNovelLabel() + ' Reader';

      // prev/next (top & bottom)
      updateNav(navEls.prevTop, i - 1);
      updateNav(navEls.nextTop, i + 1);
      updateNav(navEls.prevBottom, i - 1);
      updateNav(navEls.nextBottom, i + 1);

      setParam('chapter', id);
      highlightActive();

      try {
  const urls = buildChapterURLs();
  const res = await fetch(urls.chapterURL(id), { cache: 'no-cache' });
        if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
        const md = await res.text();
        articleEl.innerHTML = marked.parse(md);
  // render comments for this chapter (deferred so it loads after content)
  scheduleGiscusRender();
        if (scrollerEl) scrollerEl.scrollTo({ top: 0, behavior: 'auto' }); // or 'smooth'
      } catch (e) {
        console.error('Failed to load chapter', id, e);
        articleEl.innerHTML = ''; // silent fail
  try { scheduleGiscusRender(); } catch (_) {}
      }
    }

  // updateNav: shows/hides a navigation control and wires it to openChapterByIndex.
  // - el: element (button or anchor)
  // - idx: index in CHAPTERS to open, or invalid index to hide the control
  function updateNav(el, idx) {
    if (idx >= 0 && idx < CHAPTERS.length) {
        el.classList.remove('hidden');
        // if it's an anchor keep href for deep-linking, otherwise attach click handler
        if (el.tagName && el.tagName.toLowerCase() === 'a') {
      el.href = buildChapterHref(CHAPTERS[idx].id);
          el.onclick = (ev) => { ev.preventDefault(); openChapterByIndex(idx); };
        } else {
          // button or other element: set a click handler and a data-target for debugging
          el.removeAttribute('href');
          el.onclick = (ev) => { ev.preventDefault(); openChapterByIndex(idx); };
        }
      } else {
        el.classList.add('hidden');
        if (el.tagName && el.tagName.toLowerCase() === 'a') el.removeAttribute('href');
        el.onclick = null;
      }
    }

    // initial load
    (async function init() {
      // Set sidebar title based on novel/repo if provided
      try {
        const h1 = document.querySelector('.sidebar h1');
        if (h1) h1.textContent = currentNovelLabel();
      } catch(e) { /* noop */ }
      await loadIndex();
      const q = getParam('chapter');
      if (q) openChapterById(q);
      else if (CHAPTERS.length > 0) openChapterByIndex(0);
    })();

    // handle browser back/forward
    window.addEventListener('popstate', () => {
      const q = getParam('chapter');
      if (q) openChapterById(q);
    });

    // Show focus outline only for keyboard navigation
    (function() {
  function handleFirstTab(e) {
    if (e.key === 'Tab') {
      document.body.classList.add('user-is-tabbing');
      window.removeEventListener('keydown', handleFirstTab);
      window.addEventListener('mousedown', handleMouseDownOnce);
      window.addEventListener('touchstart', handleMouseDownOnce);
    }
  }
  function handleMouseDownOnce() {
    document.body.classList.remove('user-is-tabbing');
    window.removeEventListener('mousedown', handleMouseDownOnce);
    window.removeEventListener('touchstart', handleMouseDownOnce);
    window.addEventListener('keydown', handleFirstTab);
  }
  window.addEventListener('keydown', handleFirstTab);
})();
  </script>
</body>
</html>
