<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Martial Peak — Reader</title>

  <!-- Yandex.Metrica counter (load early in head) -->
  <script>
    (function(m,e,t,r,i,k,a){
      m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
      m[i].l=1*new Date();
      for (var j=0;j<document.scripts.length;j++){ if(document.scripts[j].src===r) return; }
      k=e.createElement(t);a=e.getElementsByTagName(t)[0];k.async=1;k.src=r;a.parentNode.insertBefore(k,a);
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=103953563','ym');
    try { ym(103953563,'init',{ssr:true,webvisor:true,trackHash:true,clickmap:true,ecommerce:'dataLayer',accurateTrackBounce:true,trackLinks:true}); } catch(_){ }
  </script>
  <noscript><div><img src="https://mc.yandex.ru/watch/103953563" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrica counter -->

  <!-- Markdown renderer -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- Noto Serif & Noto Sans loaded from Google Fonts. Request only 400 and 700 to reduce download size. -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;700&family=Noto+Sans:wght@400;700&display=swap" rel="stylesheet">

  <style>
    /* THEME TOKENS */
    :root[data-theme="white"] {
  --bg: #ffffff;           /* pure white */
  --fg: #1f2328;           /* near-black text */
  --muted: #6e7781;        /* neutral muted */
  --primary: #0969da;      /* GitHub-like blue */
  --surface: #f6f8fa;      /* light gray surface */
  --border: #d0d7de;       /* neutral border */
  --link: #0969da;         /* link blue */
    }
    :root[data-theme="light"] {
  --bg: #f4ecd8;           /* sepia background, less yellow */
  --fg: #5b4636;           /* readable brown text */
  --muted: #a58c6f;        /* muted brown */
  --primary: #b5853e;      /* warm accent */
  --surface: #f7f3e6;      /* lighter sepia for surfaces, less yellow */
  --border: #e0d6c3;       /* soft border */
  --link: #a86b32;         /* brownish link */
    }
    :root[data-theme="dark"] {
  --bg: #18222d;           /* deep blue-gray background */
  --fg: #c7d4e6;           /* cool light blue text */
  --muted: #6b7a8f;        /* muted blue-gray */
  --primary: #4f8cc9;      /* blue accent */
  --surface: #223042;      /* lighter blue-gray for surfaces */
  --border: #2c3a4d;       /* soft blue border */
  --link: #7ec3fa;         /* bright blue link */
    }
    :root[data-theme="black"] {
  --bg: #0d1117;           /* GitHub dark */
  --fg: #e6edf3;           /* light text */
  --muted: #7d8590;        /* muted gray */
  --primary: #2f81f7;      /* accent blue */
  --surface: #161b22;      /* dark surface */
  --border: #30363d;       /* border gray */
  --link: #2f81f7;         /* link blue */
    }
    
    /* ====== Layout tokens (tweak these to change spacing/sizes globally) ======
       --header-h: height of the top header
       --settings-rail-w: width of the right-side settings rail
       --icon-btn-size: square hit area for small header/rail buttons (do NOT confuse with glyph size)
       --icon-glyph-size: visual size of the SVG icon inside the button
    */
    :root { 
      --header-h: 56px; /* adjust if you like */
      --settings-rail-w: 72px; /* change to widen/narrow the settings rail in one place */
      --icon-btn-size: 42px;   /* hit/touch area for .icon-btn */
      --icon-glyph-size: 20px; /* visual size of the SVG glyph inside the button */
  /* global font family used across the site (can be toggled via settings) */
  --global-font-family: 'Noto Serif', serif;
  /* global font weight (400 recommended) */
  --global-font-weight: 400;
  /* a comfortable, stable width for UI rails (navs, comments, etc.), independent of article width */
  --ui-rail-w: 760px;
  /* minimum width for rails so they don't shrink excessively */
  --ui-rail-min: 520px;
  /* horizontal page gutter (mobile/tablet); bumped so reader matches the previous home feel */
  --page-gutter: clamp(26px, calc(6vw + 8px), 36px);
    }
    header.site-header { min-height: var(--header-h); }

    :root{
  --content-w: 64ch; /* optimal default ~60–70 characters on desktop */
    }

    /* Donate (theme-aware, scoped) */
  .donate-section { margin: 18px 0 8px; display: flex; justify-content: center; align-items: center; gap: 10px; flex-direction: column; opacity: 0; transform: translateY(4px); transition: opacity .25s ease, transform .25s ease; }
  .donate-section.ready { opacity: 1; transform: translateY(0); }
    .tele-btn, .donate-btn, .patreon-btn {
      cursor: pointer;
      border: none;
      padding: 10px 14px;
      border-radius: 10px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      text-decoration: none;
      box-shadow: 0 2px 4px rgba(0,0,0,.15);
      transition: transform .15s ease, box-shadow .15s ease, filter .2s ease;
      line-height: 1.1;
      font-family: 'Noto Sans','Noto Serif',var(--global-font-family),system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: .2px;
    }
  .tele-btn { background: linear-gradient(135deg,#2AABEE,#229ED9); color: #fff; }
    .tele-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,.25); }
    .tele-btn svg { width: 18px; height: 18px; }
  /* Patreon button: same style as telegram, different colors */
  .patreon-btn { background: linear-gradient(135deg,#FF6A6F,#FF424D); color: #fff; text-decoration: none; }
    .patreon-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,.25); text-decoration: none; }
    .patreon-btn svg { width: 18px; height: 18px; }
  /* BTC donate button recolored to #e09438 with a soft gradient */
  .donate-btn { background: linear-gradient(135deg,#f1a24f,#e09438); color: #fff; }
    .donate-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,.25); filter: brightness(1.05); }
    .donate-btn:active, .tele-btn:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0,0,0,.2); }
    .donate-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.55); display: none; align-items: center; justify-content: center; z-index: 1300; }
    .donate-backdrop.show { display: flex; }
  .donate-modal { background: var(--surface); color: var(--fg); border: 1px solid var(--border); border-radius: 14px; max-width: 420px; width: calc(100% - 24px); box-shadow: 0 16px 48px rgba(0,0,0,.35); }
  .donate-hdr { display: flex; gap: 10px; align-items: center; justify-content: space-between; padding: 10px 14px; border-bottom: 1px solid var(--border); }
    .donate-title { font-size: 1.05rem; margin: 0; }
  .donate-close { cursor: pointer; border: 1px solid var(--border); background: var(--bg); color: var(--fg); border-radius: 8px; padding: 4px 8px; font-size: .85rem; }
  .donate-content { padding: 12px 14px 10px; }
  .donate-lead { color: var(--muted); margin: 0 0 10px; font-size: .85rem; line-height: 1.3; }
  .donate-grid { display: block; }
    @media (min-width: 760px) { .donate-grid { grid-template-columns: repeat(3, 1fr); } }
  .donate-net { border: none; border-radius: 10px; padding: 0; background: transparent; display: flex; flex-direction: column; gap: 8px; }
  .donate-net h3 { font-size: .95rem; margin: 0 0 2px; display: flex; align-items: center; gap: 8px; justify-content: center; }
    .donate-badge { font-size: .72rem; color: var(--bg); background: color-mix(in oklab, var(--primary), white 10%); padding: 2px 8px; border-radius: 999px; }
  .donate-addr { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: .8rem; line-height: 1.25; color: var(--fg); background: var(--bg); border: 1px dashed var(--border); border-radius: 8px; padding: 8px 8px; word-break: break-all; text-align: center; }
  .donate-row { display: flex; gap: 6px; align-items: center; justify-content: center; }
  .donate-btn-sm { cursor: pointer; border: 1px solid var(--border); background: var(--surface); color: var(--fg); padding: 6px 9px; border-radius: 8px; font-weight: 600; font-size: .75rem; }
    .donate-btn-sm.ok { outline: 2px solid color-mix(in oklab, #34d399, transparent 70%); border-color: color-mix(in oklab, #34d399, var(--border) 60%); }
  .donate-qr { display: none; align-items: center; justify-content: center; background: var(--bg); border: 1px solid var(--border); border-radius: 10px; padding: 6px; margin-top: 4px; }
  .donate-foot { padding: 0 14px 12px; color: var(--muted); font-size: .7rem; text-align: center; }

    


    /* LAYOUT */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      /* use the global font family so the whole UI follows the selected Noto family */
      font: 16px/1.6 var(--global-font-family, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji");
  font-weight: var(--global-font-weight, 400);
    }
    html, body, .chapter-list, .scroller { overscroll-behavior: contain; }

    /* global hidden helper (keeps layout space like your .nav rule) */
    .hidden { visibility: hidden; }


    .app {
      display: grid;
      grid-template-columns: 280px 1fr;
      height: 100dvh; /* dynamic viewport */
      max-height: 100dvh;
      overflow: hidden; /* prevent outer scroll pass-through */
      transition: grid-template-columns .2s ease;
    }
    /* desktop collapse state */
    body.sidebar-collapsed .app { grid-template-columns: 0 1fr; }
    /* you already have: body.sidebar-collapsed .app { grid-template-columns: 0 1fr; } */
    body.sidebar-collapsed .sidebar {
      width: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
      border: 0 !important;
      overflow: hidden !important;
    }
    body.sidebar-collapsed .sidebar * { display: none !important; } /* hide children so nothing paints */


    /* SIDEBAR */
    .sidebar {
      background: var(--surface);
      border-right: 1px solid var(--border);
      padding: 12px;
      position: relative;
      z-index: 1100; /* above the overlay */
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden; /* contain internal scroller */
    }

    .sidebar h1{
    text-align:center;
    margin: 6px 0 10px;
    font-size: 18px;
    font-weight: 700;
    }

    .chapter-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .no-results {
      padding: 10px;
      margin: 8px 0;
      text-align: center;
      color: var(--muted);
      font-size: 14px;
    }
    .no-results.hidden { display: none; }
    /* Chapter search input inside the left sidebar */
    .chapter-search {
      width: 100%;
      box-sizing: border-box;
  padding: 8px 10px;
  padding-right: 40px; /* space for the clear button */
      margin: 6px 0 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--fg);
      font: inherit;
    }
    /* Hide native browser 'clear' / search-cancel decorations so only our clear button is shown */
    .chapter-search::-webkit-search-decoration,
    .chapter-search::-webkit-search-cancel-button,
    .chapter-search::-webkit-search-results-button,
    .chapter-search::-webkit-search-results-decoration {
      display: none !important;
      -webkit-appearance: none;
    }
    /* wrapper so we can place a clear button inside the input area */
    .chapter-search-wrap { position: relative; }
    .chapter-search-clear {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      border: none;
      background: transparent;
      color: var(--muted);
      width: 28px;
      height: 28px;
      display: inline-grid;
      place-items: center;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      padding: 0;
  z-index: 2; /* ensure it sits above the input text */
    }
    .chapter-search-clear:hover { color: var(--fg); }
    /* Remove browser outline but provide a subtle theme-aware focus ring */
    .chapter-search:focus {
      outline: none;
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 12%, transparent);
      border-color: var(--primary);
    }
    /* placeholder color should adapt to the theme */
    .chapter-search::placeholder { color: color-mix(in srgb, var(--muted) 70%, transparent); }
    /* make clear button visually hidden when input is empty */
    .chapter-search-clear.hidden { display: none; }
    .chapter-list a {
      display: block;
      padding: 8px 10px;
      border-radius: 8px;
      color: var(--fg);
      text-decoration: none;
      border: 1px solid transparent;
    }
    .chapter-list a:hover {
      background: rgba(127,127,127,.08);
      border-color: var(--border);
    }
    .chapter-list a.active {
      background: rgba(99,102,241,0.12);
      border-color: var(--primary);
      color: var(--primary);
      font-weight: 600;
    }

    /* keep the layout inside the viewport on every device */
    html, body { overflow-x: hidden; }

    /* prevent long titles from stretching the header */
    #chapterTitle {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* keep chapter content within the screen */
    article#article {
      max-width: 100%;
      overflow-wrap: anywhere;   /* handles super-long words/links */
      word-break: break-word;
    }

    /* make wide content responsive */
    article#article img,
    article#article table,
    article#article iframe {
      max-width: 100%;
      height: auto;
    }


    /* CONTENT */
    /* Let the whole right column scroll so the scrollbar is at the viewport edge */
    /* Right column no longer scrolls itself */
    .content {
      display: flex;
      flex-direction: column;
      min-width: 0;
      min-height: 0;
  overflow: visible;                /* allow scrolling if child overflows */
    }

        /* New: inner scroller so the track sits at far right,
      and does NOT run behind the sticky header */
    .scroller {
      flex: 1 1 auto;
      min-height: 0;
  overflow-y: auto;                 /* always allow vertical scrolling */
      scrollbar-gutter: stable;         /* keeps a gutter so layout doesn’t jump */
      scroll-padding-top: var(--header-h);  /* anchors don’t hide under header */
    }

    header.site-header {
      position: sticky;
      top: 0;
      z-index: 1002;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      height: var(--header-h);     /* ← explicit height */
      background: var(--surface);
      border-bottom: 1px solid var(--border);
    }

    @media (min-width: 901px) {
      .site-header.hide-on-scroll {
        left: 280px; /* sidebar width */
        width: calc(100% - 280px);
      }
      body.sidebar-collapsed .site-header.hide-on-scroll {
        left: 0;
        width: 100%;
      }
    }
    

    /* BUTTONS (theme + arrows share the same style) */
    /* shared style for theme + arrow buttons */
    /* Small circular/square icon buttons used in the header and settings rail.
       Important: these define the hit area (touch target). The actual icon inside
       is sized via --icon-glyph-size so you can make the glyph larger/smaller
       independently of touch size for consistent UX.
    */
    .icon-btn {
      background: none;
      border: 1px solid var(--border);
      border-radius: 10px;
      width: var(--icon-btn-size);
      height: var(--icon-btn-size);
      display: inline-grid;
      place-items: center;
      cursor: pointer;
      color: var(--fg);
      text-decoration: none;
  font-size: 20px;
  line-height: 1;
      padding: 0;
    }

    /* visual disabled state for icon buttons (used on home preview) */
    .icon-btn[disabled] {
      opacity: 0.45;
      cursor: not-allowed;
      pointer-events: none;
    }

    /* make the numeric line-spacing label smaller and use the reader serif font */
    #s-lineSpacing {
      font-size: 13px; /* slightly smaller than other icons */
      font-family: var(--global-font-family, 'Noto Serif', serif);
      line-height: 1;
      padding: 0;
    }
  /* hyphen toggle small serif label */
  #s-hyphenToggle { font-size: 12px; font-family: var(--global-font-family, 'Noto Serif', serif); }

  /* Remove all button states: no :active, :focus, :hover, or toggled styles. */

    @media (max-width: 900px) {
      /* slightly larger touch targets on phones */
    }

    /* visual size of the svg glyph inside the button; keep glyph smaller than hit area */
    .icon-btn svg { width: var(--icon-glyph-size); height: var(--icon-glyph-size); display: block; }
  /* make the font-cycle button itself use the active reader font so the "F" previews the selection */
  #s-fontCycle { font-family: var(--global-font-family, 'Noto Serif', serif); font-weight: var(--global-font-weight, 400); -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
  /* weight-toggle removed - reclaimed space in settings rail */

    /* Settings sidebar (right) */
    .settings-sidebar {
      position: fixed;
      top: 0;
      right: 0;
      width: var(--settings-rail-w);
      height: 100vh;
      background: var(--surface);
      border-left: 1px solid var(--border);
      box-shadow: -2px 0 12px rgba(0,0,0,0.08);
      display: flex;
      align-items: flex-start;    /* align content to the top */
      justify-content: flex-start;
      z-index: 1100;              /* match left sidebar stacking for consistent overlay ordering */
      transform: translateX(100%);
      transition: transform .25s cubic-bezier(.2,.8,.2,1);
      will-change: transform;     /* hint for smoother animation */
    }
    .settings-sidebar.open { transform: translateX(0); }
    /* Desktop: respect body.settings-open to reveal a compact right rail */
    @media (min-width: 901px) {
      body.settings-open .settings-sidebar { transform: translateX(0); }
      /* reserve a small right margin when settings rail is open so content doesn't shift awkwardly */
  body.settings-open .app { margin-right: var(--settings-rail-w); transition: margin-right .25s cubic-bezier(.2,.8,.2,1); }
    }
    /* place controls centered horizontally and aligned vertically to the header (same level as the cog) */
    .settings-inner {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
    /* position first button so its center lines up with the header center.
      42px is the .icon-btn height; adjust if you change button size
      add a small nudge so the control aligns with the cog distance from the top edge */
    padding-top: 17px;
      align-items: center; /* center horizontally */
      box-sizing: border-box;
    }
  /* reuse icon-btn visuals for cog button; push it to the far right of the tools */
  #cogBtn { display:inline-grid; place-items:center; margin-left: auto; align-self:center; }

    @media (max-width: 900px) {
      .icon-btn svg { width: 22px; height: 22px; }
    }


  /* No hover effect. */

    /* HAMBURGER */
    .menu {
      background: none;
      border: none;
      display: inline-flex;
      flex-direction: column;
      gap: 4px;
      padding: 8px;
      cursor: pointer;
    }
    .menu span {
      width: 24px;
      height: 2.5px;
      background: var(--fg);
      border-radius: 2px;
      transition: background .2s ease;
    }

    .tools {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    main.reader {
      flex: 0 0 auto;
      overflow: visible;
      box-sizing: border-box;
      max-width: 100%;                  /* allow UI to use full column width */
      margin: 0 auto;
      /* restore comfortable side gutter on mobile, honoring safe areas */
      padding: 0px max(var(--page-gutter), env(safe-area-inset-left)) 40px max(var(--page-gutter), env(safe-area-inset-right));
    }
    @media (min-width: 901px){
      main.reader{ padding: 0px 24px 56px; }
    }


    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin: 10px 0 18px;
    }

    /* Keep navigation bars and comments within a centered UI rail.
       - width grows up to --ui-rail-w (capped by viewport)
       - never shrinks below --ui-rail-min (but never exceeds viewport)
       - independent of the article width so controls stay usable when text column is very narrow */
    .nav, #giscusContainer {
      width: min(100%, var(--ui-rail-w));
      max-width: min(100%, var(--ui-rail-w));
      min-width: min(100%, var(--ui-rail-min));
      margin-left: auto;
      margin-right: auto;
    }
  /* Make sure the embedded giscus frame fills the container */
  #giscusContainer .giscus, #giscusContainer iframe.giscus-frame { display: block; width: 100% !important; max-width: 100% !important; }

  article#article {
    font-size: 18px;
    font-family: var(--global-font-family, 'Noto Serif', serif);
  font-weight: var(--global-font-weight, 400);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    max-width: var(--content-w);    /* constrain only the reading text */
    margin: 0 auto;                 /* center it within the reader column */
    /* Justify body copy for a book-like reading experience */
    text-align: justify;
    text-justify: inter-word;
    -webkit-hyphens: auto;
    -moz-hyphens: auto;
    hyphens: auto;
    /* allow long words to break if needed */
    overflow-wrap: anywhere;
  }

  /* ensure sidebar h1 and header chapter title remain bold regardless of global weight */
  .sidebar h1, #chapterTitle { font-weight: 700; }
    article#article h1, article#article h2, article#article h3 {
      line-height: 1.25;
      margin-top: 1.4em;
      /* keep headings left-aligned so they don't center with justified body text */
      text-align: left;
    }
  article#article p { margin: 1em 0; }
  /* paragraph indent support when user enables it (applies to article paragraphs) */
  .para-indent article#article p { text-indent: 1.25em; }
    article#article hr {
      border: 0;
      border-top: 1px solid var(--border);
      margin: 2rem 0;
    }
    article#article a { color: var(--link); }

    /* OVERLAY for mobile only */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.45);
      display: none;
      z-index: 1095; /* below sidebars (1100) */
    }
    .overlay.show { display: block; }

    /* MOBILE */
    @media (max-width: 900px) {
      .app { grid-template-columns: 1fr; }          /* sidebar column hidden */

      .sidebar{
        position: fixed;
        left: 0; top: 0; bottom: 0;
        transform: translateX(-100%);
        transition: transform .25s ease;
        width: min(85vw, 320px);
        z-index: 1100;                               /* above page header */
        background: var(--surface);
        border-right: 1px solid var(--border);
        overflow-y: auto;                             /* drawer scrolls */
        padding-top: 10px;  /* space from top */
      }
      .sidebar.open{ transform: translateX(0); }

      /* Simple title — centered, no sticky */
      .sidebar h1{
        text-align:center;
        margin: 16px 0 10px;
        padding: 0px 16px;
        text-align: center;
        font-size: 18px;
        font-weight: 700;
      }

      /* List sits right under the title */
      .sidebar ul{
        margin: 0;
        padding: 0;
      }

      /* overlay sits below drawer but above content */
      .overlay{ z-index: 1090; }
  /* settings sidebar mobile alignment */
  .settings-sidebar { top: 0; padding-top: 0px; z-index: 1100; }
  .settings-sidebar.open { transform: translateX(0); }
    }

  /* Sidebar scrolling model: fixed header (title + search) + scrolling chapter list */
  .sidebar h1 { margin-top: 0; padding-top: 4px; flex-shrink: 0; }
  .sidebar .chapter-search-wrap { flex-shrink: 0; }
  .chapter-list { flex: 1 1 auto; overflow-y: auto; margin-top: 4px; padding-right: 4px; }
  .chapter-list::-webkit-scrollbar { width: 10px; }
  .chapter-list::-webkit-scrollbar-track { background: transparent; }
  .chapter-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 6px; }
  .chapter-list::-webkit-scrollbar-thumb:hover { background: color-mix(in oklab, var(--border), var(--fg) 25%); }

  /* HOME PANEL (shown when no ?chapter param) */
  #homePanel { max-width: 760px; margin: 32px auto 56px; padding: 0; font-family: var(--global-font-family,'Noto Serif',serif); }
  #homePanel[hidden] { display: none !important; }
  .home-hero h2 { font-size: clamp(1.9rem, 4.5vw, 2.6rem); line-height: 1.15; margin: 0 0 .6em; font-weight: 700; letter-spacing: -.5px; }
  .home-lead { font-size: 1.05rem; line-height: 1.5; margin: 0 0 1.4em; color: var(--muted); }
  .home-grid { display: grid; gap: 18px; margin: 34px 0 40px; }
  @media (min-width: 640px){ .home-grid { grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); } }
  .home-card { background: var(--surface); border: 1px solid var(--border); border-radius: 14px; padding: 16px 18px 18px; display:flex; flex-direction:column; gap:8px; }
  .home-card h3 { margin: 0; font-size: .95rem; letter-spacing: .5px; text-transform: uppercase; font-weight: 700; color: var(--primary); }
  .home-card p { margin: 0; font-size: .8rem; line-height: 1.4; color: var(--fg); }
  .home-actions { display:flex; flex-wrap:wrap; gap:12px; margin-top: 6px; align-items: flex-start; }
  .home-actions .row-break { flex-basis:100%; height:0; }
  /* Vertical stack for Patreon, Telegram, BTC */
  .cta-stack { display:flex; flex-direction: column; align-items: flex-start; gap:10px; margin-top:10px; flex-basis:100%; width:100%; }
  /* Patrons banner (shared on home and chapter pages) */
  .patrons-banner { box-sizing: border-box; margin: 42px auto 10px; max-width: var(--ui-rail-w, 760px); width: 100%; padding: 0 var(--page-gutter, 20px); text-align: center; }
  .patrons-mount { display: flex; justify-content: center; }
  .patrons-title { font-size: clamp(1.4rem, 3vw, 1.9rem); font-weight: 800; letter-spacing: .5px; margin: 0 0 10px; color: var(--fg); }
  .patrons-hr { height: 1px; max-width: 86%; width: 100%; margin: 6px auto 18px; background: linear-gradient(90deg, transparent, color-mix(in oklab, var(--primary), var(--fg) 35%), transparent); opacity: .6; }
  .patrons-names { display: grid; gap: 8px; justify-items: center; }
  .patron-name { font-size: 1.05rem; font-weight: 700; color: var(--fg); }
  .patrons-banner .thanks { margin-top: 12px; font-size: .85rem; color: var(--muted); }
  .patrons-subtext { margin-top: 6px; font-size: .78rem; color: var(--muted); }
  /* Make the Patrons CTA use the same style as the primary button */
  .patrons-banner .btn-primary { margin-top: 10px; }
  /* Primary CTA (neutral styling to avoid clashing, still prominent via size/weight/shadow) */
  .btn-primary {
    background: var(--surface);
    color: var(--fg);
    border: 1px solid var(--border);
    padding:12px 20px;
    font-size: 15px;
    font-weight:700;
    border-radius: 10px;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:8px;
    box-shadow: 0 2px 6px rgba(0,0,0,.10);
  transition: transform .15s ease, box-shadow .15s ease, background-color .2s ease;
  text-decoration: none;
  }
  .btn-primary:hover { transform: translateY(-1px); box-shadow:0 4px 10px rgba(0,0,0,.16); background: color-mix(in oklab, var(--surface), var(--fg) 6%); }
  #chapterTitle { cursor: pointer; }
  .btn-secondary {
    background: var(--surface);
    color: var(--fg);
    border:1px solid var(--border);
    padding:12px 20px;
    font-size:15px;
    font-weight:700;
    border-radius:10px;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:8px;
    box-shadow: 0 2px 6px rgba(0,0,0,.10);
    transition: transform .15s ease, box-shadow .15s ease, background-color .2s ease;
  }
  .btn-secondary:hover { transform: translateY(-1px); box-shadow:0 4px 10px rgba(0,0,0,.16); background: color-mix(in oklab, var(--surface), var(--fg) 6%); }
  .home-note { font-size: .68rem; text-transform: uppercase; letter-spacing: 1px; color: var(--muted); margin-top: 10px; }
  .home-badge { display:inline-block; background: color-mix(in oklab, var(--primary), white 20%); color: var(--bg); font-size: .65rem; padding:4px 8px; border-radius: 999px; letter-spacing: .5px; font-weight:600; margin-right: 8px; }
  .home-mini { font-size: .72rem; line-height: 1.35; color: var(--muted); margin-top: 4px; }
  .home-divider { height:1px; background: var(--border); margin: 40px 0 34px; border:0; }
  .home-inline-link { color: var(--link); text-decoration: none; font-weight:600; }
  .home-inline-link:hover { text-decoration: underline; }
  .home-disclaimer { font-size: .65rem; line-height:1.4; color: var(--muted); margin-top: 40px; text-align: center; }
  .home-flex { display:flex; flex-direction:column; gap: 14px; }
  .home-kicker { font-size: .7rem; font-weight:700; letter-spacing:2px; color: var(--primary); text-transform:uppercase; margin:0 0 14px; }
  #homeAuthor { font-size: 1.3rem; font-weight:600; letter-spacing:.3px; margin: 2px 0 20px; color: var(--fg); }
  .recent-wrapper { margin: 34px 0 10px; }
  .recent-title { margin:0 0 14px; font-size: 1.05rem; font-weight:700; letter-spacing:.4px; }
  .recent-table { width:100%; border-collapse: collapse; font-size:.8rem; }
  .recent-table thead th { text-align:left; font-weight:600; padding:6px 6px; border-bottom:1px solid var(--border); color: var(--muted); font-size:.7rem; letter-spacing:.7px; text-transform:uppercase; }
  .recent-table tbody td { padding:6px 6px; border-bottom:1px solid color-mix(in oklab, var(--border), transparent 40%); }
  .recent-table tbody tr:last-child td { border-bottom:none; }
  .recent-table a { color: var(--link); text-decoration:none; }
  .recent-table a:hover { text-decoration:underline; }
  /* Spoiler blur for chapter titles (recent list) */
  .spoiler-blur { filter: blur(5px); cursor: pointer; transition: filter .18s ease; display:inline; font-weight:600; color: var(--link); }
  /* Prevent subpixel reflow by promoting to its own layer */
  .spoiler-blur, .spoiler-blur.revealed { will-change: filter; }
  .spoiler-blur.revealed { filter:none; }
  .chapter-number-link { font-weight:600; margin-right:0; }
  .chapter-dash { font-weight:600; color: var(--link); }
  .recent-date { white-space:nowrap; font-variant-numeric: tabular-nums; color: var(--muted); }
  .recent-empty { font-size:.75rem; color: var(--muted); padding: 4px 0 0; }
  @media (max-width:600px){
   /* Mobile: make each recent row a 2-column grid: title (1fr) + date (auto).
     This prevents overflow, lets titles wrap naturally, and keeps dates tight. */
   .recent-wrapper { margin: 18px 0 10px; padding: 0 8px; box-sizing: border-box; }
   .recent-table { width: 100%; table-layout: auto; font-size: .78rem; border-collapse: collapse; }
   .recent-table thead { display: table-header-group; }
  .recent-table tbody tr { display: table-row; }
  .recent-table tbody td { display: table-cell; padding: 6px 6px; box-sizing: border-box; vertical-align: middle; }
  .recent-table tbody td:nth-child(2) { width: 1%; white-space: nowrap; text-align: right; color: var(--muted); font-size: .75rem; }
  .recent-table tbody td:nth-child(1) { overflow-wrap: anywhere; white-space: normal; }
   .recent-date.hide-narrow { display: table-cell; }
  }


  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar" id="sidebar">
      <h1>Martial Peak</h1>
      <div class="chapter-search-wrap">
        <input id="chapterSearch" class="chapter-search" type="text" placeholder="Search chapters…" aria-label="Search chapters">
        <button id="chapterSearchClear" class="chapter-search-clear" aria-label="Clear search">✕</button>
      </div>
  <div id="chaptersNoResults" class="no-results hidden" aria-live="polite"></div>
      <ul class="chapter-list" id="chaptersList"></ul>
    </aside>

    <div class="content">
      <!--
        Header: contains the hamburger menu, current chapter title, and header tools.
        - #menuBtn toggles the left chapter drawer (mobile) or collapses the sidebar (desktop)
        - #chapterTitle shows the current chapter's title
        - .tools holds inline header controls (arrows + cog). Most controls are shared
          with the right settings rail to keep behavior consistent.
      -->
      <header class="site-header">
        <button class="menu" id="menuBtn" aria-label="Menu">
          <span></span><span></span><span></span>
        </button>
        <strong id="chapterTitle">Loading…</strong>
  <div class="tools">
          <!-- font controls moved into the settings sidebar on the right -->
          <!-- top nav arrows (these are buttons for consistent semantics/accessibility) -->
          <button id="prevTop" class="icon-btn hidden" aria-label="Previous">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
          </button>
          <button id="nextTop" class="icon-btn hidden" aria-label="Next">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </button>
          <button id="cogBtn" class="icon-btn" title="Settings" aria-label="Settings" data-ym-goal="settings_open">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33h.09A1.65 1.65 0 0 0 11 3.09V3a2 2 0 0 1 4 0v.09c.38.16.7.46 1 1.51a1.65 1.65 0 0 0 1.82.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82c.16.38.46.7 1.51 1H21a2 2 0 0 1 0 4h-.09c-.16.38-.46.7-1.51 1z"></path></svg>
          </button>
        </div>
      </header>

      <div class="scroller">
        <main class="reader">
          <section id="homePanel" aria-labelledby="homeTitle" hidden>
            <div class="home-hero" id="homeHero">
              <p class="home-kicker" id="homeBrand">Courting Death Translations</p>
              <h2 id="homeTitle">Loading…</h2>
              <p id="homeAuthor" class="home-mini" style="margin-top:-4px; display:none;"></p>
              <div id="homeAnnotation"></div>
              <div class="home-actions">
                <button id="startReadingBtn" class="btn-primary" type="button" data-ym-goal="start_reading">Start Reading →</button>
                <button id="firstUnreadBtn" class="btn-secondary" type="button" style="display:none;">Resume Reading →</button>
                <div class="cta-stack" data-cta-target></div>
              </div>
              <div id="recentChapters" class="recent-wrapper" hidden>
                <h3 class="recent-title">Recent Chapters</h3>
                <div class="recent-body"></div>
              </div>
              <div class="patrons-mount" data-patrons-target="home"></div>
              <p id="homeDisclaimer" class="home-disclaimer reader-intro" style="margin-top:34px;"></p>
            </div>
          </section>
          <nav class="nav" id="topNav" style="display:none;"></nav> <!-- kept for structure -->
          <article id="article"></article>
          <!-- Donate trigger -->
          <nav class="nav" id="bottomNav">
            <button id="prevBottom" class="icon-btn hidden" aria-label="Previous">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <polyline points="15 18 9 12 15 6"></polyline>
              </svg>
            </button>
            <div class="donate-section" data-cta-target></div>
            <button id="nextBottom" class="icon-btn hidden" aria-label="Next">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <polyline points="9 18 15 12 9 6"></polyline>
              </svg>
            </button>
          </nav>
          
          <!-- Reusable CTA template (buttons only). Will be cloned into any [data-cta-target] containers above. -->
          <template id="ctaButtonsTpl">
            <a href="https://www.patreon.com/c/courting_death" target="_blank" rel="noopener" class="patreon-btn" aria-label="Patreon" data-ym-goal="cta_patreon" data-ym-label="patreon">
              <svg viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <rect x="20" y="20" width="52" height="216" fill="#fff"/>
                <circle cx="156" cy="104" r="80" fill="#fff"/>
              </svg>
              Support and get EPUBs
            </a>
            <a href="https://t.me/meecosha" target="_blank" rel="noopener" class="tele-btn" aria-label="Telegram Channel" data-ym-goal="cta_telegram" data-ym-label="telegram">
              <svg viewBox="0 0 240 240" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <circle cx="120" cy="120" r="120" fill="url(#tggrad)" />
                <path d="M173 72L151.4 170.6c-1.6 7.2-6 9-12.2 5.6l-34-25.2-16.4 15.8c-1.8 1.8-3.2 3.2-6.4 3.2l2.2-32.2 58.6-52.8c2.6-2.2-.6-3.4-4-1.2l-72.4 45.6-31.2-9.8c-6.8-2.2-6.8-6.8 1.4-10.2l122-47.2c5.6-2 10.4 1.2 8.6 9.8Z" fill="#fff" />
                <defs>
                  <linearGradient id="tggrad" x1="0" y1="0" x2="1" y2="1">
                    <stop stop-color="#37B7F4" />
                    <stop offset="1" stop-color="#1E96C8" />
                  </linearGradient>
                </defs>
              </svg>
              My Telegram Channel
            </a>
            <button class="donate-btn" type="button" data-ym-goal="cta_donate_open" data-ym-label="donate_open">Send some Bitcoin 🤍</button>
          </template>

          <!-- Reusable Patrons banner template -->
          <template id="patronsTpl">
            <section class="patrons-banner" aria-labelledby="patronsTitle">
              <h3 id="patronsTitle" class="patrons-title">Immortal Ancestor Patrons</h3>
              <div class="patrons-hr" aria-hidden="true"></div>
              <div class="patrons-names" role="list"></div>
              <a class="btn-primary" href="https://www.patreon.com/cw/courting_death/membership" target="_blank" rel="noopener" data-ym-goal="patrons_cta" data-ym-label="patrons_cta">Become an Immortal Ancestor Patron</a>
              <div class="patrons-subtext">join before the next translation begins, and your name shall be etched here forever</div>
              
            </section>
          </template>

          <!-- Comments -->
          <div id="giscusContainer" style="margin-top:24px;"></div>
          <div class="patrons-mount" data-patrons-target="chapter"></div>
        </main>
      </div>
    </div>
  </div>
  <aside class="settings-sidebar" id="settingsSidebar" aria-hidden="true">
    <!--
      Right settings rail: compact vertical controls for font + theme.
      - Sits off-canvas on mobile and as a compact rail on desktop when body.settings-open
      - Buttons here invoke the same handlers as header controls (reuse behavior)
    -->
    <div class="settings-inner" role="menu" aria-label="Settings">
  <button id="s-themeBtn" class="icon-btn" title="Toggle theme" aria-label="Toggle theme" data-ym-goal="settings_theme_toggle">🌓</button>
  <button id="s-fontInc" class="icon-btn" title="Increase font size" aria-label="Increase font size" data-ym-goal="settings_font_inc">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
      </button>
  <button id="s-fontDec" class="icon-btn" title="Decrease font size" aria-label="Decrease font size" data-ym-goal="settings_font_dec">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
      </button>
      <!-- Cycle reader font family: Droid Serif ↔ Helvetica -->
  <button id="s-fontCycle" class="icon-btn" title="Cycle font family" aria-label="Cycle font family" data-ym-goal="settings_font_cycle">F</button>
  <!-- font-weight toggle removed to save space -->

      <!-- Text alignment toggle: cycles justify | left | center | right -->
  <button id="s-alignToggle" class="icon-btn" title="Text align: Justify" aria-label="Text align: Justify" data-ym-goal="settings_align_toggle">
        <!-- default icon (will be replaced on load) -->
        <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="4" y1="6" x2="20" y2="6"></line>
          <line x1="4" y1="10" x2="20" y2="10"></line>
          <line x1="4" y1="14" x2="20" y2="14"></line>
          <line x1="4" y1="18" x2="20" y2="18"></line>
        </svg>
      </button>

      <!-- Paragraph indent toggle: toggles first-line indent on/off -->
  <button id="s-indentToggle" class="icon-btn" title="Paragraph indent: Off" aria-label="Paragraph indent: Off" data-ym-goal="settings_indent_toggle">
        <!-- default icon (updated by JS) -->
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="4" y1="6" x2="20" y2="6"></line>
          <line x1="4" y1="10" x2="20" y2="10"></line>
          <line x1="4" y1="14" x2="20" y2="14"></line>
        </svg>
      </button>

      <!-- Line spacing toggle: cycles 1.0 | 1.1 | 1.2 | 1.3 | 1.4 | 1.5 -->
  <button id="s-lineSpacing" class="icon-btn" title="Line spacing: 1.2" aria-label="Line spacing: 1.2" data-ym-goal="settings_line_spacing">1.2</button>
  <!-- Hyphenation toggle: toggles hyphens on/off for the article -->
  <button id="s-hyphenToggle" class="icon-btn" title="Hyphenation: On" aria-label="Hyphenation: On" data-ym-goal="settings_hyphen_toggle">Hy</button>

  <!-- Content-width controls: narrow / widen readable column -->
  <button id="s-contentInc" class="icon-btn" title="Widen column" aria-label="Widen column" data-ym-goal="settings_content_inc">
    <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <!-- left arrow pointing left -->
      <polyline points="10 6, 4 12, 10 18"></polyline>
      <!-- right arrow pointing right -->
      <polyline points="14 6, 20 12, 14 18"></polyline>
    </svg>
  </button>

  
  <button id="s-contentDec" class="icon-btn" title="Narrow column" aria-label="Narrow column" data-ym-goal="settings_content_dec">
    <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2"
      stroke-linecap="round" stroke-linejoin="round">
      <!-- left arrow pointing right -->
      <polyline points="4 6, 10 12, 4 18"></polyline>
      <!-- right arrow pointing left -->
      <polyline points="20 6, 14 12, 20 18"></polyline>
    </svg>
  </button>

<button id="s-reset" class="icon-btn" title="Reset" aria-label="Reset" data-ym-goal="settings_reset">
  <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
    <!-- flipped circular arc -->
    <g transform="rotate(191 12 12)">
      <path d="M21 12a9 9 0 1 0-3 6.74" />
      <!-- corner arrow head at the bottom-right -->
      <polyline points="15 16 20 15 21 20" />
    </g>
  </svg>
</button>







      </div>
  
  </aside>

  <div class="overlay" id="overlay"></div>
  
  <!-- Donate Modal -->
  <div id="donateModal" class="donate-backdrop" role="dialog" aria-modal="true" aria-labelledby="donateTitle">
    <div class="donate-modal">
      <div class="donate-hdr">
        <h2 id="donateTitle" class="donate-title">Support the Courting Death Translations!</h2>
        <button class="donate-close" id="closeDonateModal" aria-label="Close">✕</button>
      </div>
      <div class="donate-content">
        <p class="donate-lead">If you'd like to support the site & translations you can send me some <strong>Bitcoin</strong>. Thank you!</p>
        <div class="donate-grid">
          <section class="donate-net" data-net="BTC" data-symbol="BTC">
            <h3>Bitcoin <span class="donate-badge">BTC</span></h3>
            <div class="donate-addr" id="addr-btc">1CVVMcmEmFRBVXq31gbbBYdDUHxpEPsqw5</div>
            <div class="donate-row">
              <button class="donate-btn-sm" data-copy="#addr-btc">Copy</button>
            </div>
            <!-- QR removed -->
          </section>
        </div>
      </div>
      <div class="donate-foot">Send only BTC to this address. Network: Bitcoin mainnet.</div>
    </div>
  </div>

  <!-- QR library removed -->
  <script>
  // ====== Small runtime guide ======
  // This script wires UI controls (menu, cog, font/theme, navigation) to shared helper
  // functions. Key persisted keys in localStorage are:
  //  - mp_theme: 'white' | 'light' | 'dark' | 'black'
  //  - mp_fontsize: number (px)

  // --- Theme ---
    const THEME_ORDER = ['white', 'light', 'dark', 'black'];
    const THEME_ICON = { white: '❄️', light: '☀️', dark: '🌙', black: '🌑' };
    function setTheme(mode) {
      document.documentElement.setAttribute('data-theme', mode);
      localStorage.setItem('mp_theme', mode);
      // update any theme buttons if present (header or sidebar)
      const headerThemeBtn = document.getElementById('themeBtn');
      const sidebarThemeBtn = document.getElementById('s-themeBtn');
      const label = THEME_ICON[mode] || '�';
      if (headerThemeBtn) headerThemeBtn.textContent = label;
      if (sidebarThemeBtn) sidebarThemeBtn.textContent = label;
      if (headerThemeBtn) { headerThemeBtn.title = `Theme: ${mode}`; headerThemeBtn.setAttribute('aria-label', `Theme: ${mode}`); }
      if (sidebarThemeBtn) { sidebarThemeBtn.title = `Theme: ${mode}`; sidebarThemeBtn.setAttribute('aria-label', `Theme: ${mode}`); }
  // sync Giscus theme if present
  try { updateGiscusTheme(mode); } catch (_) {}
    }
  // Ensure sensible defaults on first run so the reader opens with these settings
  if (!localStorage.getItem('mp_theme')) localStorage.setItem('mp_theme', 'light');
  if (!localStorage.getItem('mp_textAlign')) localStorage.setItem('mp_textAlign', 'justify');
  if (!localStorage.getItem('mp_readerFont')) localStorage.setItem('mp_readerFont', 'noto-serif');
  if (!localStorage.getItem('mp_paraIndent')) localStorage.setItem('mp_paraIndent', '1');
  if (!localStorage.getItem('mp_fontsize')) localStorage.setItem('mp_fontsize', '20');
  if (!localStorage.getItem('mp_contentw')) localStorage.setItem('mp_contentw', '64');
  // reader weight toggle removed; keep default typography consistent via --global-font-weight
  if (!localStorage.getItem('mp_lineHeight')) localStorage.setItem('mp_lineHeight', '1.3');
  // apply theme from storage (now present)
  setTheme(localStorage.getItem('mp_theme'));
  // ensure CSS variable for global font weight defaults to 400 on first run
  if (!localStorage.getItem('mp_readerWeight')) {
    document.documentElement.style.setProperty('--global-font-weight', '400');
  }

  // Font size controls
  // Note: There are two places for font controls — header (optional) and settings rail.
  // We wire both to the same handlers so behavior is identical.
  const fontInc = document.getElementById('fontInc');
  const fontDec = document.getElementById('fontDec');
  const sFontInc = document.getElementById('s-fontInc');
  const sFontDec = document.getElementById('s-fontDec');
  const sReset = document.getElementById('s-reset');
  const article = document.getElementById('article');
    function getFontSize() {
      return parseFloat(window.getComputedStyle(article).fontSize);
    }
    function setFontSize(size) {
      article.style.fontSize = size + 'px';
      localStorage.setItem('mp_fontsize', size);
    }
    if (fontInc) {
      fontInc.addEventListener('click', () => {
        setFontSize(Math.min(getFontSize() + 2, 36));
      });
    }
    if (fontDec) {
      fontDec.addEventListener('click', () => {
        setFontSize(Math.max(getFontSize() - 2, 12));
      });
    }
  if (sFontInc) sFontInc.addEventListener('click', () => setFontSize(Math.min(getFontSize() + 2, 36)));
  if (sFontDec) sFontDec.addEventListener('click', () => setFontSize(Math.max(getFontSize() - 2, 12)));
    // Load saved font size
    const savedFont = localStorage.getItem('mp_fontsize');
    if (savedFont) setFontSize(parseFloat(savedFont));
  function cycleTheme() {
      const current = localStorage.getItem('mp_theme') || 'light';
      const idx = THEME_ORDER.indexOf(current);
      const next = THEME_ORDER[(idx >= 0 ? idx + 1 : 0) % THEME_ORDER.length];
      setTheme(next);
    }

  // --- Reader font family cycling ---
  const sFontCycle = document.getElementById('s-fontCycle');
  const READER_FONTS = [
    { id: 'noto-serif', name: 'Noto Serif', css: "'Noto Serif', serif" },
    { id: 'noto-sans', name: 'Noto Sans', css: "'Noto Sans', sans-serif" }
  ];
  const DEFAULT_READER_ID = 'noto-serif';
  function applyReaderFontById(id) {
    const f = READER_FONTS.find(x => x.id === id) || READER_FONTS[0];
  // set the global font family token so the whole UI follows
  document.documentElement.style.setProperty('--global-font-family', f.css);
    localStorage.setItem('mp_readerFont', f.id);
    const lbl = document.getElementById('s-contentLabel');
  // show font name and content width; weight toggle removed
  if (lbl) lbl.textContent = f.name + ' • ' + getContentWCh() + 'ch';
  }
  function cycleReaderFont() {
    const curId = localStorage.getItem('mp_readerFont') || DEFAULT_READER_ID;
    const idx = Math.max(0, READER_FONTS.findIndex(f => f.id === curId));
    const next = READER_FONTS[(idx + 1) % READER_FONTS.length];
    applyReaderFontById(next.id);
  }
  if (sFontCycle) sFontCycle.addEventListener('click', cycleReaderFont);
  // Restore saved reader font on load (use id-based storage)
  const savedReaderFontId = localStorage.getItem('mp_readerFont');
  if (savedReaderFontId) applyReaderFontById(savedReaderFontId);
  else applyReaderFontById(DEFAULT_READER_ID);

  // --- Reset settings (except theme) ---
  function resetSettingsExceptTheme() {
    const theme = localStorage.getItem('mp_theme') || 'light';
    // Clear all but keep theme value
    try {
      localStorage.clear();
    } catch (_) {}
    // Reapply defaults
    localStorage.setItem('mp_theme', theme);
    localStorage.setItem('mp_textAlign', 'justify');
    localStorage.setItem('mp_readerFont', DEFAULT_READER_ID);
    localStorage.setItem('mp_paraIndent', '1');
    localStorage.setItem('mp_fontsize', '20');
  localStorage.setItem('mp_contentw', '64');
    localStorage.setItem('mp_lineHeight', '1.3');
    // Re-apply UI state
    setTheme(theme);
    applyReaderFontById(DEFAULT_READER_ID);
    setFontSize(parseFloat(localStorage.getItem('mp_fontsize')));
    applyAlignment(localStorage.getItem('mp_textAlign'));
    applyParaIndent(!!localStorage.getItem('mp_paraIndent'));
    const savedLine = parseFloat(localStorage.getItem('mp_lineHeight') || '1.2');
    applyLineSpacing(isNaN(savedLine) ? 1.2 : savedLine);
    const savedContentW = localStorage.getItem('mp_contentw');
    if (savedContentW) setContentWCh(parseFloat(savedContentW));
  }
  if (sReset) sReset.addEventListener('click', resetSettingsExceptTheme);

  // reader font weight toggle removed (no longer used)

  // --- Sidebar open/close ---
  // Elements that control drawers/overlays. The code distinguishes mobile vs desktop
  // behavior: mobile uses slide + overlay; desktop toggles compact columns without overlay.
  const sidebar = document.getElementById('sidebar');
  const overlay = document.getElementById('overlay');
  const menuBtn = document.getElementById('menuBtn');
  const cogBtn = document.getElementById('cogBtn');
  const settingsSidebar = document.getElementById('settingsSidebar');
  const sThemeBtn = document.getElementById('s-themeBtn');
  const isMobile = () => window.matchMedia('(max-width: 900px)').matches;

    function openSidebarMobile(){ sidebar.classList.add('open'); overlay.classList.add('show'); }
    function closeSidebarMobile(){ sidebar.classList.remove('open'); overlay.classList.remove('show'); }

  function openSettingsMobile(){ settingsSidebar.classList.add('open'); overlay.classList.add('show'); settingsSidebar.setAttribute('aria-hidden','false'); }
  function closeSettingsMobile(){ settingsSidebar.classList.remove('open'); overlay.classList.remove('show'); settingsSidebar.setAttribute('aria-hidden','true'); }

    menuBtn.addEventListener('click', () => {
      if (isMobile()) {
        // mobile: slide drawer with overlay
        sidebar.classList.contains('open') ? closeSidebarMobile() : openSidebarMobile();
      } else {
        // desktop: collapse/expand sidebar; NEVER show overlay on desktop
        document.body.classList.toggle('sidebar-collapsed');
        overlay.classList.remove('show');
      }
    });
    overlay.addEventListener('click', () => { closeSidebarMobile(); closeSettingsMobile(); });
    window.addEventListener('resize', () => { if (!isMobile()) overlay.classList.remove('show'); });

    // cog button — toggles right settings drawer (mirror of hamburger but on the right)
    if (cogBtn) {
      cogBtn.addEventListener('click', () => {
        if (isMobile()) {
          settingsSidebar.classList.contains('open') ? closeSettingsMobile() : openSettingsMobile();
        } else {
          // desktop: toggle a class to show/hide the settings column (no overlay on desktop)
          document.body.classList.toggle('settings-open');
        }
      });
    }

    // wire the small sidebar theme button to the same theme toggler
  if (sThemeBtn) { sThemeBtn.addEventListener('click', cycleTheme); }

    // --- Content-width controls (readable column width) ---
    const sContentInc = document.getElementById('s-contentInc');
    const sContentDec = document.getElementById('s-contentDec');
    const sContentLabel = document.getElementById('s-contentLabel');

    function getContentWCh() {
  const raw = getComputedStyle(document.documentElement).getPropertyValue('--content-w') || '64ch';
      return parseFloat(raw);
    }
    function pxPerCh() {
      // Measure 1ch using the article's current font metrics for accuracy.
      const base = document.getElementById('article') || document.documentElement;
      const el = document.createElement('span');
      el.style.position = 'absolute';
      el.style.visibility = 'hidden';
      el.style.width = '1ch';
      el.style.font = getComputedStyle(base).font;
      document.body.appendChild(el);
      const w = el.getBoundingClientRect().width || el.offsetWidth || 8;
      document.body.removeChild(el);
      return w;
    }

    // --- Text alignment toggle (justify | left | center | right) ---
    const sAlignToggle = document.getElementById('s-alignToggle');
    const ALIGN_MODES = ['justify','left','center','right'];
    const ALIGN_ICONS = {
      justify: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="6" x2="20" y2="6"></line><line x1="4" y1="10" x2="20" y2="10"></line><line x1="4" y1="14" x2="20" y2="14"></line><line x1="4" y1="18" x2="20" y2="18"></line></svg>',
      left: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="6" x2="12" y2="6"></line><line x1="4" y1="10" x2="16" y2="10"></line><line x1="4" y1="14" x2="12" y2="14"></line><line x1="4" y1="18" x2="16" y2="18"></line></svg>',
      center: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="6" x2="18" y2="6"></line><line x1="8" y1="10" x2="16" y2="10"></line><line x1="6" y1="14" x2="18" y2="14"></line><line x1="8" y1="18" x2="16" y2="18"></line></svg>',
      right: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="6" x2="20" y2="6"></line><line x1="8" y1="10" x2="20" y2="10"></line><line x1="12" y1="14" x2="20" y2="14"></line><line x1="8" y1="18" x2="20" y2="18"></line></svg>'
    };

    function applyAlignment(mode) {
      if (!mode) mode = 'justify';
      mode = ALIGN_MODES.includes(mode) ? mode : 'justify';
      // apply to article
      article.style.textAlign = mode === 'justify' ? 'justify' : mode;
      // store for persistence
      localStorage.setItem('mp_textAlign', mode);
      // update the toggle icon/title
      if (sAlignToggle) {
        sAlignToggle.innerHTML = ALIGN_ICONS[mode] || ALIGN_ICONS.justify;
        sAlignToggle.title = 'Text align: ' + mode.charAt(0).toUpperCase() + mode.slice(1);
        sAlignToggle.setAttribute('aria-label', 'Text align: ' + mode);
      }
    }

    function cycleAlignment() {
      const cur = localStorage.getItem('mp_textAlign') || 'justify';
      const idx = Math.max(0, ALIGN_MODES.indexOf(cur));
      const next = ALIGN_MODES[(idx + 1) % ALIGN_MODES.length];
      applyAlignment(next);
    }

    if (sAlignToggle) sAlignToggle.addEventListener('click', cycleAlignment);
    // restore saved alignment on load
    const savedAlign = localStorage.getItem('mp_textAlign') || 'justify';
    applyAlignment(savedAlign);

    // --- Paragraph indent toggle ---
    const sIndentToggle = document.getElementById('s-indentToggle');
    const INDENT_ICON = {
      on: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="6" width="4" height="12" rx="1"></rect><line x1="11" y1="10" x2="21" y2="10"></line><line x1="11" y1="14" x2="21" y2="14"></line></svg>',
      off: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="8" x2="20" y2="8"></line><line x1="4" y1="12" x2="20" y2="12"></line><line x1="4" y1="16" x2="20" y2="16"></line></svg>'
    };

    function applyParaIndent(enabled) {
      const on = Boolean(enabled);
      if (on) {
        // add a class so CSS can style first-line indent
        document.documentElement.classList.add('para-indent');
        localStorage.setItem('mp_paraIndent', '1');
      } else {
        document.documentElement.classList.remove('para-indent');
        localStorage.removeItem('mp_paraIndent');
      }
      if (sIndentToggle) {
        sIndentToggle.innerHTML = on ? INDENT_ICON.on : INDENT_ICON.off;
        sIndentToggle.title = 'Paragraph indent: ' + (on ? 'On' : 'Off');
        sIndentToggle.setAttribute('aria-label', 'Paragraph indent: ' + (on ? 'On' : 'Off'));
      }
    }

    function toggleParaIndent() {
      const cur = !!localStorage.getItem('mp_paraIndent');
      applyParaIndent(!cur);
    }

    if (sIndentToggle) sIndentToggle.addEventListener('click', toggleParaIndent);
    // restore saved indent state
    const savedIndent = !!localStorage.getItem('mp_paraIndent');
    applyParaIndent(savedIndent);

    // --- Line spacing toggle (1.0 -> 1.1 -> 1.2 -> 1.3 -> 1.4 -> 1.5) ---
    const sLineSpacing = document.getElementById('s-lineSpacing');
  const LINE_SPACES = [1.2, 1.3, 1.4, 1.5];

    function applyLineSpacing(val) {
      let v = Number(val) || 1.2;
      // normalize to one of the supported steps
      if (!LINE_SPACES.includes(v)) {
        // find nearest
        v = LINE_SPACES.reduce((prev, curr) => Math.abs(curr - v) < Math.abs(prev - v) ? curr : prev, LINE_SPACES[0]);
      }
      article.style.lineHeight = String(v);
      localStorage.setItem('mp_lineHeight', String(v));
      if (sLineSpacing) {
        sLineSpacing.textContent = String(v);
        sLineSpacing.title = 'Line spacing: ' + v;
        sLineSpacing.setAttribute('aria-label', 'Line spacing: ' + v);
      }
    }

    function cycleLineSpacing() {
      const cur = parseFloat(localStorage.getItem('mp_lineHeight') || '1.2');
      const idx = Math.max(0, LINE_SPACES.findIndex(x => Math.abs(x - cur) < 0.001));
      const next = LINE_SPACES[(idx + 1) % LINE_SPACES.length];
      applyLineSpacing(next);
    }

    if (sLineSpacing) sLineSpacing.addEventListener('click', cycleLineSpacing);
    // restore saved line-height or default to 1.2
  const savedLine = parseFloat(localStorage.getItem('mp_lineHeight') || '1.2');
  applyLineSpacing(isNaN(savedLine) ? 1.2 : savedLine);

    // --- Hyphenation toggle ---
    const sHyphenToggle = document.getElementById('s-hyphenToggle');
    function applyHyphens(enabled) {
      const on = Boolean(enabled);
      if (on) {
        article.style.hyphens = 'auto';
        document.documentElement.classList.add('hyphens-on');
        localStorage.setItem('mp_hyphens', '1');
      } else {
        article.style.hyphens = 'none';
        document.documentElement.classList.remove('hyphens-on');
        localStorage.removeItem('mp_hyphens');
      }
      if (sHyphenToggle) {
        sHyphenToggle.textContent = 'Hy';
        sHyphenToggle.title = 'Hyphenation: ' + (on ? 'On' : 'Off');
        sHyphenToggle.setAttribute('aria-label', 'Hyphenation: ' + (on ? 'On' : 'Off'));
      }
    }
    function toggleHyphens() { applyHyphens(!!localStorage.getItem('mp_hyphens') ? false : true); }
    if (sHyphenToggle) sHyphenToggle.addEventListener('click', toggleHyphens);
    // restore hyphenation state
    applyHyphens(!!localStorage.getItem('mp_hyphens'));

    function viewportChAvailable() {
      const chPx = pxPerCh();
      const reader = document.querySelector('main.reader');
      const scroller = document.querySelector('.scroller');
      // Use the right column's inner viewport width (scroller), not the full window width.
      let containerPx = (scroller && scroller.clientWidth) || window.innerWidth;
      let padLeft = 0, padRight = 0;
      if (reader) {
        const cs = getComputedStyle(reader);
        const pl = parseFloat(cs.paddingLeft);
        const pr = parseFloat(cs.paddingRight);
        padLeft = Number.isFinite(pl) ? pl : 0;
        padRight = Number.isFinite(pr) ? pr : 0;
      }
      const availablePx = Math.max(0, containerPx - padLeft - padRight);
      return Math.max(1, Math.floor(availablePx / chPx));
    }

    function setContentWCh(n) {
      const clamped = Math.max(20, Math.min(n, 240)); // bounds in ch
      const avail = viewportChAvailable();
      const applied = Math.min(clamped, avail);
      document.documentElement.style.setProperty('--content-w', applied + 'ch');
  try { localStorage.setItem('mp_contentw', String(applied)); } catch(_){ }
  if (sContentLabel) sContentLabel.textContent = applied + 'ch';
    }
    if (sContentInc) sContentInc.addEventListener('click', () => setContentWCh(getContentWCh() + 4));
    if (sContentDec) sContentDec.addEventListener('click', () => setContentWCh(getContentWCh() - 4));
    // restore saved content width
    const savedContentW = localStorage.getItem('mp_contentw');
    if (savedContentW) setContentWCh(parseFloat(savedContentW));
    else if (sContentLabel) sContentLabel.textContent = getContentWCh() + 'ch';
    // Adjust content width if viewport shrinks smaller than current setting
    window.addEventListener('resize', () => {
      try {
        const avail = viewportChAvailable();
        const current = getContentWCh();
        if (current > avail) setContentWCh(avail);
        else if (sContentLabel) sContentLabel.textContent = current + 'ch';
      } catch (e) { /* noop */ }
    });

  // --- Helpers ---
  // Short helper for querying elements and named references used below.
  const qs = (sel) => document.querySelector(sel);
  const titleEl = qs('#chapterTitle');
  const chaptersListEl = qs('#chaptersList');
  const chapterSearchEl = qs('#chapterSearch');
  const articleEl = qs('#article');
  const scrollerEl = document.querySelector('.scroller');

  // Inject reusable CTA buttons into all targets marked with [data-cta-target]
  function hydrateCtas(){
    const tpl = document.getElementById('ctaButtonsTpl');
    if (!tpl) return;
    document.querySelectorAll('[data-cta-target]').forEach((target)=>{
      if (target.dataset.ctaHydrated === '1') return;
      // Clear existing children (in case of stale markup) and clone template
      target.innerHTML = '';
      target.appendChild(tpl.content.cloneNode(true));
      target.dataset.ctaHydrated = '1';
    });
  }

  // Inject Patrons banner into all [data-patrons-target] and populate from novel repo's Patrons.md
  async function hydratePatrons(){
    try {
      const tpl = document.getElementById('patronsTpl');
      if (!tpl) return;
      // Determine current view
      const isHome = !!(typeof getParam === 'function' ? !getParam('chapter') : (document.getElementById('homePanel') && !document.getElementById('homePanel').hidden));
      const targetSel = isHome ? '[data-patrons-target="home"]' : '[data-patrons-target="chapter"]';
      const otherSel  = isHome ? '[data-patrons-target="chapter"]' : '[data-patrons-target="home"]';
      // Clear the non-active mount to avoid duplicates when switching views
      document.querySelectorAll(otherSel).forEach((t)=>{ t.innerHTML = ''; t.dataset.patronsHydrated = ''; });
      // Hydrate only the active mount(s)
      document.querySelectorAll(targetSel).forEach((target)=>{
        if (target.dataset.patronsHydrated === '1') return;
        target.innerHTML = '';
        target.appendChild(tpl.content.cloneNode(true));
        target.dataset.patronsHydrated = '1';
      });

      const ref = resolveRepoRef();
      let url = null;
      if (ref) url = `https://raw.githubusercontent.com/${ref.owner}/${ref.repo}/${ref.branch}/Patrons.md`;
      else url = 'Patrons.md';
      if (!url) return;
      let text = '';
      try {
        const r = await fetch(url, { cache: 'no-cache' });
        if (!r.ok) throw new Error('HTTP '+r.status);
        text = await r.text();
      } catch (_) { return; }

      const lines = text.split(/\r?\n/)
        .map(s=>s.trim())
        .filter(s=> s && !s.startsWith('#'))
        .map(s=> s.replace(/^[-*+]\s+/, ''));
      if (!lines.length) return;
  document.querySelectorAll(`${targetSel} .patrons-banner .patrons-names`).forEach(list => {
        list.innerHTML = '';
        lines.forEach(name => {
          const div = document.createElement('div');
          div.className = 'patron-name';
          div.setAttribute('role','listitem');
          div.textContent = name;
          list.appendChild(div);
        });
      });
    } catch (_) {}
  }

  // --- Donate: BTC modal & real QR generation ---
  const BTC_ADDRESS = '1CVVMcmEmFRBVXq31gbbBYdDUHxpEPsqw5';

    const donateModal = document.getElementById('donateModal');
    const donateCloseBtn = document.getElementById('closeDonateModal');
    function openDonate(){ donateModal.classList.add('show'); trapDonateFocus(); }
    function closeDonate(){ donateModal.classList.remove('show'); document.removeEventListener('keydown', donateEscClose); }
    function donateEscClose(e){ if(e.key==='Escape') closeDonate(); }
    // Open donate modal on any button with .donate-btn (delegated to document)
    document.addEventListener('click', (e)=>{
      const btn = e.target && e.target.closest && e.target.closest('.donate-btn');
      if (!btn) return;
      document.addEventListener('keydown', donateEscClose);
      openDonate();
    });
    if (donateCloseBtn) donateCloseBtn.addEventListener('click', closeDonate);
    if (donateModal) donateModal.addEventListener('click', (e)=>{ if(e.target===donateModal) closeDonate(); });

  // (address already in markup; left here for consistency if later made dynamic)
  const elBtc = document.getElementById('addr-btc'); if (elBtc) elBtc.textContent = BTC_ADDRESS;

    // QR + Copy handlers (event delegation)
    document.addEventListener('click', (e)=>{
      const copySel = e.target.closest('[data-copy]');
      if (copySel) {
        const sel = copySel.getAttribute('data-copy');
        const valEl = document.querySelector(sel);
        if (valEl) {
          const val = valEl.textContent.trim();
          navigator.clipboard.writeText(val).then(()=>{
            copySel.classList.add('ok'); setTimeout(()=>copySel.classList.remove('ok'), 900);
            try { if (typeof ym==='function') ym(103953563, 'reachGoal', 'donate_copy_btc', { view: (getParam('chapter')? 'chapter':'home') }); } catch(_){ }
          }).catch(()=>{});
        }
        return;
      }
  // QR functionality removed
    });

  // ===== Yandex.Metrica: delegated click tracking for all important buttons =====
  document.addEventListener('click', (e) => {
    // find closest element with a tracking goal
    const el = e.target && e.target.closest && e.target.closest('[data-ym-goal]');
    if (!el) return;
    // Skip chapter nav arrows explicitly (not tagged by us, but guard anyway)
    const id = el.id || '';
    if (id === 'prevTop' || id === 'nextTop' || id === 'prevBottom' || id === 'nextBottom') return;
    // Skip chapter list clicks (left sidebar) entirely
    if (el.closest && el.closest('#chaptersList')) return;

    const goal = el.getAttribute('data-ym-goal');
    if (!goal) return;
    const params = {
      view: (typeof getParam==='function' && getParam('chapter')) ? 'chapter' : 'home',
      chapterId: (typeof getParam==='function' ? (getParam('chapter') || null) : null),
      label: el.getAttribute('data-ym-label') || null
    };
    try { if (typeof ym==='function') ym(103953563, 'reachGoal', goal, params); } catch(_) {}
  });

    // Focus trap for modal accessibility
    function trapDonateFocus(){
      if (!donateModal) return;
      const focusable = donateModal.querySelectorAll('button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])');
      const first = focusable[0]; const last = focusable[focusable.length-1];
      first && first.focus();
      function loop(e){
        if(e.key!== 'Tab') return;
        if(e.shiftKey && document.activeElement===first){ e.preventDefault(); last.focus(); }
        else if(!e.shiftKey && document.activeElement===last){ e.preventDefault(); first.focus(); }
      }
      donateModal.addEventListener('keydown', loop, { once:true });
    }

    // --- Mobile swipe gestures (edge-swipe to open sidebars) ---
    (function setupSwipeGestures() {
      let startX = 0, startY = 0, tracking = false, fromEdge = null; // 'left' | 'right' | null
      const EDGE_PX = 100;        // how close to the edge a swipe must start
      const MIN_X = 60;          // minimum horizontal travel to count as a swipe
      const MAX_Y = 40;          // max vertical deviation to treat as horizontal swipe

      const surface = scrollerEl || document;

      surface.addEventListener('touchstart', (e) => {
        if (!isMobile()) return;
        if (!e.touches || e.touches.length !== 1) { tracking = false; return; }
        const t = e.touches[0];
        startX = t.clientX; startY = t.clientY; tracking = true; fromEdge = null;
        if (startX <= EDGE_PX) fromEdge = 'left';
        else if (startX >= window.innerWidth - EDGE_PX) fromEdge = 'right';
      }, { passive: true });

      surface.addEventListener('touchmove', (e) => {
        // We keep this passive; we don't want to block vertical scrolling.
        if (!tracking) return;
        if (!isMobile()) { tracking = false; return; }
      }, { passive: true });

      surface.addEventListener('touchend', (e) => {
        if (!tracking) return; tracking = false;
        if (!isMobile()) return;
        const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
        if (!t) return;
        const dx = t.clientX - startX;
        const dy = t.clientY - startY;
        if (Math.abs(dy) > MAX_Y) return; // likely a vertical scroll

        const leftOpen = sidebar && sidebar.classList.contains('open');
        const rightOpen = settingsSidebar && settingsSidebar.classList.contains('open');

        // Edge-intent open gestures
        if (fromEdge === 'left' && dx > MIN_X && !leftOpen) {
          openSidebarMobile();
          return;
        }
        if (fromEdge === 'right' && dx < -MIN_X && !rightOpen) {
          openSettingsMobile();
          return;
        }

        // Convenience close gestures when already open
        if (leftOpen && dx < -MIN_X) { closeSidebarMobile(); return; }
        if (rightOpen && dx > MIN_X) { closeSettingsMobile(); return; }
      }, { passive: true });
    })();


    // Navigation button refs (top header and bottom nav share the same handlers)
    const navEls = {
      prevTop: qs('#prevTop'),
      nextTop: qs('#nextTop'),
      prevBottom: qs('#prevBottom'),
      nextBottom: qs('#nextBottom'),
    };

    function getParam(name) {
      const url = new URL(window.location.href);
      return url.searchParams.get(name);
    }
    function setParam(name, value) {
      const url = new URL(window.location.href);
      if (value == null) url.searchParams.delete(name);
      else url.searchParams.set(name, value);
      history.pushState({}, '', url);
    }
    function normalizeId(id) {
      if (!id) return id;
      return id.endsWith('.md') ? id.slice(0, -3) : id;
    }

    // --- External chapters support (fetch from other repos) ---
    // Allow specifying a novel by key (?novel=martial-peak) or an explicit repo (?repo=courting-death/martial-peak)
    // Optional branch via ?branch=<name> (defaults to main).
    const OWNER = 'courting-death';
    const NOVEL_MAP = {
      'martial-peak': 'martial-peak'
    };

    // Per-novel Discussions (ID-based) used by Giscus
    // Fill this with repo/category IDs per novel repository.
    const NOVEL_DISCUSSIONS = {
      'courting-death/martial-peak': {
        repoId: 'R_kgDOPgGOOA',
        category: 'Chapters',
        categoryId: 'DIC_kwDOPgGOOM4CuUCY'
      }
    };

    const qpNovel  = getParam('novel');
    const qpRepo   = getParam('repo');
    const qpBranch = getParam('branch') || 'main';

    function resolveRepoRef() {
      if (qpRepo) {
        const [owner, repo] = qpRepo.split('/');
        if (owner && repo) return { owner, repo, branch: qpBranch };
      }
      if (qpNovel && NOVEL_MAP[qpNovel]) {
        return { owner: OWNER, repo: NOVEL_MAP[qpNovel], branch: qpBranch };
      }
      return null; // use local chapters folder
    }

    function buildChapterURLs() {
      const ref = resolveRepoRef();
      if (!ref) {
        return {
          baseIndex: 'chapters/chapters.json',
          chapterURL: (id) => `chapters/${id}.md`,
        };
      }
      const { owner, repo, branch } = ref;
      const base = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/chapters`;
      return {
        baseIndex: `${base}/chapters.json`,
        chapterURL: (id) => `${base}/${id}.md`,
      };
    }

    // Build href for chapter links while preserving existing query params (novel/repo/branch)
    function buildChapterHref(id) {
      const url = new URL(window.location.href);
      if (id == null) url.searchParams.delete('chapter');
      else url.searchParams.set('chapter', id);
      return `${url.pathname}?${url.searchParams.toString()}`;
    }

    // Human label for current novel/repo to use in titles/headers
    function toTitleCase(s) { return (s || '').replace(/[-_]+/g, ' ').replace(/\b\w/g, c => c.toUpperCase()); }
    function currentNovelLabel() {
      if (qpRepo) {
        const parts = qpRepo.split('/');
        return toTitleCase(parts[1] || qpRepo);
      }
      if (qpNovel) return toTitleCase(qpNovel);
      // fallback to existing hard-coded label
      return 'Martial Peak';
    }

    // ====== Giscus helpers ======
    function currentRepoKey() {
      const ref = resolveRepoRef();
      return ref ? `${ref.owner}/${ref.repo}` : null;
    }
    function currentChapterId() {
      return (CHAPTERS[currentIndex] && CHAPTERS[currentIndex].id) || null;
    }

    // Enable or disable specific settings controls in the settings rail.
    // - allowedIds: null to enable all, or array of element ids to allow; all others will be disabled.
    function setSettingsAvailability(allowedIds) {
      try {
        const container = document.querySelector('.settings-inner');
        if (!container) return;
        const buttons = Array.from(container.querySelectorAll('.icon-btn'));
        // when allowedIds is null -> enable all
        const allowAll = allowedIds == null;
        buttons.forEach(btn => {
          const id = btn.id;
          if (allowAll || (Array.isArray(allowedIds) && allowedIds.includes(id))) {
            btn.removeAttribute('disabled');
            btn.classList.remove('disabled');
            btn.setAttribute('aria-disabled', 'false');
          } else {
            btn.setAttribute('disabled', '');
            btn.classList.add('disabled');
            btn.setAttribute('aria-disabled', 'true');
          }
        });
      } catch (_) {}
    }
  // Map site themes to Giscus built-in themes
    function giscusThemeFor(mode) {
      // giscus supports 'light' and 'dark' built-ins; map our white->light, light->light, dark->dark, black->dark
      if (mode === 'dark') return 'transparent_dark';
      if (mode === 'black') return 'transparent_dark';
      if (mode === 'light') return 'light';
      if (mode === 'white') return 'light';
    }
    function updateGiscusTheme(mode) {
      const iframe = document.querySelector('iframe.giscus-frame');
      if (!iframe) return;
      iframe.contentWindow.postMessage({ giscus: { setConfig: { theme: giscusThemeFor(mode) } } }, 'https://giscus.app');
    }
    function renderGiscus() {
      const container = document.getElementById('giscusContainer');
      if (!container) return;
      const repoKey = currentRepoKey();
      const chap = currentChapterId();
      if (!repoKey || !chap) { container.innerHTML = ''; return; }
  const term = `${repoKey}:${chap}`;

      // clear previous instance and inject a fresh script
      container.innerHTML = '';
      const s = document.createElement('script');
      s.src = 'https://giscus.app/client.js';
      s.async = true;
      s.crossOrigin = 'anonymous';
      s.setAttribute('data-repo', repoKey);
      const conf = NOVEL_DISCUSSIONS[repoKey] || {};
      if (conf.repoId) s.setAttribute('data-repo-id', conf.repoId);
      s.setAttribute('data-category', conf.category || 'Chapters');
      if (conf.categoryId) s.setAttribute('data-category-id', conf.categoryId);
      s.setAttribute('data-mapping', 'specific');
      s.setAttribute('data-term', term);
      s.setAttribute('data-strict', '1');
      s.setAttribute('data-reactions-enabled', '1');
      s.setAttribute('data-emit-metadata', '0');
      s.setAttribute('data-input-position', 'top');
      s.setAttribute('data-theme', giscusThemeFor(localStorage.getItem('mp_theme') || 'light'));
      s.setAttribute('data-lang', 'en');
      s.setAttribute('data-loading', 'eager');
      container.appendChild(s);
    }

    // Defer Giscus rendering so comments load after the chapter content
    let giscusTimeoutId = null;
    let giscusIdleId = null;
    function cancelScheduledGiscus() {
      if (giscusTimeoutId) { clearTimeout(giscusTimeoutId); giscusTimeoutId = null; }
      if (giscusIdleId && 'cancelIdleCallback' in window) { cancelIdleCallback(giscusIdleId); giscusIdleId = null; }
    }
    function scheduleGiscusRender(delayMs = 800) {
      cancelScheduledGiscus();
      const run = () => { giscusTimeoutId = null; giscusIdleId = null; try { renderGiscus(); } catch (_) {} };
      if ('requestIdleCallback' in window) {
        giscusIdleId = requestIdleCallback(run, { timeout: delayMs + 200 });
        giscusTimeoutId = setTimeout(() => { if (giscusIdleId) { cancelIdleCallback(giscusIdleId); giscusIdleId = null; } run(); }, delayMs);
      } else {
        giscusTimeoutId = setTimeout(run, delayMs);
      }
    }

    // --- Load chapters index ---
    let CHAPTERS = [];        // [{ id, title }]
    let currentIndex = -1;    // index in CHAPTERS

    async function loadIndex() {
      const urls = buildChapterURLs();
      try {
        const res = await fetch(urls.baseIndex, { cache: 'no-cache' });
        CHAPTERS = await res.json();
      } catch (e) {
        console.error('Failed to load chapters.json', e);
        CHAPTERS = [];
      }
      renderList();
    }

    // --- Chapter search: live filter the rendered list ---
    function applyChapterFilter() {
      renderList();
      // keep active highlight in sync
      highlightActive();
    }
    if (chapterSearchEl) {
      const chapterSearchClear = document.getElementById('chapterSearchClear');
      const updateClearVisibility = () => {
        if (!chapterSearchClear) return;
        if (chapterSearchEl.value && chapterSearchEl.value.trim().length) chapterSearchClear.classList.remove('hidden');
        else chapterSearchClear.classList.add('hidden');
      };
      // initialize clear button visibility
      updateClearVisibility();
      if (chapterSearchClear) chapterSearchClear.addEventListener('click', (ev) => {
        ev.preventDefault();
        chapterSearchEl.value = '';
        updateClearVisibility();
        applyChapterFilter();
        chapterSearchEl.focus();
      });
      chapterSearchEl.addEventListener('input', (e) => {
        updateClearVisibility();
        applyChapterFilter();
      });
      chapterSearchEl.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
          // open first visible match
          const first = chaptersListEl.querySelector('a');
          if (first) {
            ev.preventDefault();
            const params = new URL(first.href).searchParams;
            const id = params.get('chapter');
            if (id) openChapterById(id);
            if (isMobile()) closeSidebarMobile();
          }
        } else if (ev.key === 'Escape') {
          chapterSearchEl.value = '';
          applyChapterFilter();
        }
      });
    }

    function renderList() {
      // If a search query exists, filter CHAPTERS by title/id
      const q = (chapterSearchEl && chapterSearchEl.value) ? chapterSearchEl.value.trim().toLowerCase() : '';
      const list = q ? CHAPTERS.filter(c => ((c.title || c.id) + '').toLowerCase().includes(q)) : CHAPTERS;
      chaptersListEl.innerHTML = '';
      const noResultsEl = document.getElementById('chaptersNoResults');
      if (!list || list.length === 0) {
        if (noResultsEl) {
          const rawQ = chapterSearchEl && chapterSearchEl.value ? chapterSearchEl.value.trim() : '';
          if (CHAPTERS.length === 0) noResultsEl.textContent = 'No chapters available';
          else if (rawQ) noResultsEl.textContent = `No results`;
          else noResultsEl.textContent = 'No chapters';
          noResultsEl.classList.remove('hidden');
        }
        return;
      }
      if (noResultsEl) noResultsEl.classList.add('hidden');
      list.forEach((c, visibleIndex) => {
        // find original index in CHAPTERS so opening uses correct index
        const i = CHAPTERS.findIndex(x => x.id === c.id);
        const li = document.createElement('li');
  const a = document.createElement('a');
  a.href = buildChapterHref(c.id);
        a.textContent = c.title || c.id;
        a.addEventListener('click', (ev) => {
          ev.preventDefault();
          openChapterByIndex(i);
          if (isMobile()) closeSidebarMobile();
        });
        li.appendChild(a);
        chaptersListEl.appendChild(li);
      });
    }

    function highlightActive() {
      const links = Array.from(chaptersListEl.querySelectorAll('a'));
      links.forEach((a) => {
        // extract chapter id from href and compare to CHAPTERS[currentIndex].id
        const href = a.getAttribute('href') || '';
        const params = new URL(href, location.origin).searchParams;
        const id = params.get('chapter');
        const isActive = (currentIndex >= 0 && CHAPTERS[currentIndex] && CHAPTERS[currentIndex].id === id);
        a.classList.toggle('active', isActive);
      });
    }

    async function openChapterById(id) {
      const norm = normalizeId(id);
      const index = CHAPTERS.findIndex(c => c.id === norm);
      if (index === -1 && CHAPTERS.length > 0) return openChapterByIndex(0);
      return openChapterByIndex(index);
    }

    async function openChapterByIndex(i) {
      if (i < 0 || i >= CHAPTERS.length) return;
  hideHome();
  // Ensure all settings controls are enabled when a real chapter is open
  try { setSettingsAvailability(null); } catch(_){}
      currentIndex = i;
  const { id, title } = CHAPTERS[i];
  titleEl.textContent = title || id;
  document.title = (title || id) + ' — ' + currentNovelLabel() + ' Reader';
  try { localStorage.setItem('mp_lastChapterId', id); } catch(_){}
  try { document.dispatchEvent(new CustomEvent('chapter:opened', { detail: { id } })); } catch(_){}

      // prev/next (top & bottom)
      updateNav(navEls.prevTop, i - 1);
      updateNav(navEls.nextTop, i + 1);
      updateNav(navEls.prevBottom, i - 1);
      updateNav(navEls.nextBottom, i + 1);

      setParam('chapter', id);
      highlightActive();

      try {
  const urls = buildChapterURLs();
  const res = await fetch(urls.chapterURL(id), { cache: 'no-cache' });
        if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
        const md = await res.text();
  articleEl.innerHTML = marked.parse(md);
  // reveal donate/telegram buttons after content paint
  try { document.querySelector('.donate-section')?.classList.add('ready'); } catch(_) {}
  // render comments for this chapter (deferred so it loads after content)
  scheduleGiscusRender();
  try { hydratePatrons(); } catch(_) {}
        if (scrollerEl) scrollerEl.scrollTo({ top: 0, behavior: 'auto' }); // or 'smooth'
      } catch (e) {
        console.error('Failed to load chapter', id, e);
  articleEl.innerHTML = ''; // silent fail
  try { document.querySelector('.donate-section')?.classList.add('ready'); } catch(_) {}
  try { scheduleGiscusRender(); } catch (_) {}
  try { hydratePatrons(); } catch(_) {}
      }
    }

  // updateNav: shows/hides a navigation control and wires it to openChapterByIndex.
  // - el: element (button or anchor)
  // - idx: index in CHAPTERS to open, or invalid index to hide the control
  function updateNav(el, idx) {
    if (idx >= 0 && idx < CHAPTERS.length) {
        el.classList.remove('hidden');
        // if it's an anchor keep href for deep-linking, otherwise attach click handler
        if (el.tagName && el.tagName.toLowerCase() === 'a') {
      el.href = buildChapterHref(CHAPTERS[idx].id);
          el.onclick = (ev) => { ev.preventDefault(); openChapterByIndex(idx); };
        } else {
          // button or other element: set a click handler and a data-target for debugging
          el.removeAttribute('href');
          el.onclick = (ev) => { ev.preventDefault(); openChapterByIndex(idx); };
        }
      } else {
        el.classList.add('hidden');
        if (el.tagName && el.tagName.toLowerCase() === 'a') el.removeAttribute('href');
        el.onclick = null;
      }
    }

    // initial load
    (async function init() {
      // Ensure CTA buttons are present in both Home and Chapter footer
      try { hydrateCtas(); } catch(_) {}
  // Render patrons banner in both placements
  try { hydratePatrons(); } catch(_) {}
      // Set sidebar title based on novel/repo if provided
      try {
        const h1 = document.querySelector('.sidebar h1');
        if (h1) h1.textContent = currentNovelLabel();
      } catch(e) { /* noop */ }
      await loadIndex();
      const q = getParam('chapter');
  if (q) openChapterById(q);
  else showHome();
    })();

    // handle browser back/forward
    window.addEventListener('popstate', () => {
      const q = getParam('chapter');
      if (q) openChapterById(q);
    });

    // Show focus outline only for keyboard navigation
    (function() {
  function handleFirstTab(e) {
    if (e.key === 'Tab') {
      document.body.classList.add('user-is-tabbing');
      window.removeEventListener('keydown', handleFirstTab);
      window.addEventListener('mousedown', handleMouseDownOnce);
      window.addEventListener('touchstart', handleMouseDownOnce);
    }
  }
  function handleMouseDownOnce() {
    document.body.classList.remove('user-is-tabbing');
    window.removeEventListener('mousedown', handleMouseDownOnce);
    window.removeEventListener('touchstart', handleMouseDownOnce);
    window.addEventListener('keydown', handleFirstTab);
  }
  window.addEventListener('keydown', handleFirstTab);
})();

  // ====== Home panel logic ======
  const homePanel = document.getElementById('homePanel');
  const startBtn = document.getElementById('startReadingBtn');
  const resumeBtn = document.getElementById('firstUnreadBtn');
  const recentWrapper = document.getElementById('recentChapters');
  const recentBody = recentWrapper ? recentWrapper.querySelector('.recent-body') : null;
  const homeTitleEl = document.getElementById('homeTitle');
  const homeAuthorEl = document.getElementById('homeAuthor');
  const homeAnnoContainer = document.getElementById('homeAnnotation');
  const homeDisclaimerEl = document.getElementById('homeDisclaimer');
  const HOME_DISCLAIMER = [
    "No MTL. Fan-made translations by Courting Death Translations.",
    "All rights to the original work belong to the respective copyright holders.",
    "Contact: courtingdeathnovels@gmail.com"
  ];
  if (homeDisclaimerEl) {
    homeDisclaimerEl.innerHTML = HOME_DISCLAIMER.map(s=>`<span>${s}</span>`).join('<br>');
  }

  function showHome(){
    if (!homePanel) return;
    // Set header title to novel label (consistent with sidebar)
    try { titleEl.textContent = currentNovelLabel(); document.title = currentNovelLabel() + ' — Reader'; } catch(_){}
  // Hide donate/comments/navigation until a chapter is opened
  document.querySelector('.donate-section')?.classList.remove('ready');
  homePanel.hidden = false;
  // Keep cog visible but disable most settings; allow only theme, font family and reset (column width not useful on home)
  try { if (cogBtn) cogBtn.classList.remove('hidden'); } catch(_){ }
  try { setSettingsAvailability(['s-themeBtn','s-fontCycle','s-reset']); } catch(_){ }
  // Ensure settings rail and any overlays are closed when on the home panel
  try { settingsSidebar.classList.remove('open'); settingsSidebar.setAttribute('aria-hidden','true'); document.body.classList.remove('settings-open'); overlay.classList.remove('show'); } catch(_){}
    // Determine resume button (if last read chapter stored)
    try {
      const last = getParam('chapter') || localStorage.getItem('mp_lastChapterId');
      if (last && CHAPTERS.some(c=>c.id===normalizeId(last))) {
        resumeBtn.style.display = 'inline-flex';
        resumeBtn.onclick = () => openChapterById(last);
      }
    } catch(_){}
  // lazy load meta info once
  if (!homePanel.dataset.metaLoaded) loadNovelMeta();
  try { buildRecentChapters(); } catch(_){ }
  try { hydratePatrons(); } catch(_) {}
  }
  function hideHome(){ if (homePanel) homePanel.hidden = true; }
  if (startBtn) startBtn.addEventListener('click', ()=> { if (CHAPTERS.length) openChapterByIndex(0); });

  // Track last opened chapter id for resume button
  const originalOpenChapterByIndex = openChapterByIndex; // kept for potential future wrapping
  document.addEventListener('chapter:opened', (e)=>{
    try { const id = e.detail && e.detail.id; if (id) localStorage.setItem('mp_lastChapterId', id); } catch(_){}
  });

  // Clickable header title -> go home (clear chapter param & show home panel)
  function goHome(){
    try { setParam('chapter', null); } catch(_){}
    currentIndex = -1;
    // clear content & comments
    try { articleEl.innerHTML = ''; document.getElementById('giscusContainer').innerHTML=''; } catch(_){}
    // hide nav buttons
    Object.values(navEls).forEach(btn=> btn && btn.classList.add('hidden'));
    showHome();
  try { hydratePatrons(); } catch(_) {}
  }
  if (titleEl) titleEl.addEventListener('click', ()=>{ goHome(); });

  // ====== Novel meta loader ======
  async function loadNovelMeta(){
    const ref = resolveRepoRef();
    let novelKey = 'martial-peak';
    if (ref) novelKey = ref.repo; // assume repo name is meta id
    const attempts = [];
    async function tryFetch(url){
      attempts.push(url);
      try { const r = await fetch(url, { cache: 'no-cache' }); if (!r.ok) return null; return await r.json(); } catch(_){ return null; }
    }
    let meta = null;
    if (ref) {
      // Preferred path inside the novel repo root
      meta = await tryFetch(`https://raw.githubusercontent.com/${ref.owner}/${ref.repo}/${ref.branch}/${novelKey}.meta.json`);
      // Secondary legacy path inside a novels/ folder of that repo
      if (!meta) meta = await tryFetch(`https://raw.githubusercontent.com/${ref.owner}/${ref.repo}/${ref.branch}/novels/${novelKey}.meta.json`);
    }
    if (!meta) { homePanel.dataset.metaLoaded = '1'; return; }
    homePanel.dataset.metaLoaded = '1';
    try {
      if (homeTitleEl) homeTitleEl.textContent = meta.name || currentNovelLabel();
      if (meta.author && homeAuthorEl) { homeAuthorEl.textContent = 'by ' + meta.author; homeAuthorEl.style.display='block'; }
      if (Array.isArray(meta.annotation) && homeAnnoContainer){
        homeAnnoContainer.innerHTML = '';
        meta.annotation.forEach(p => {
          const el = document.createElement('p');
            el.className = 'home-lead reader-intro';
            el.textContent = p;
            homeAnnoContainer.appendChild(el);
        });
      }
  // Disclaimer/contact intentionally fixed site-wide; ignore per-novel values
    } catch(_){ }
  }

  function formatDate(dStr){
    if(!dStr) return '';
    const d = new Date(dStr);
    if (isNaN(+d)) return '';
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const da = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${da}`;
  }
  function buildRecentChapters(limit=10){
    if (!recentWrapper || !recentBody || !Array.isArray(CHAPTERS) || CHAPTERS.length===0) return;
    // Prefer sorting by numeric chapter id (e.g. 123) descending so the latest chapter appears first.
    function chapterNumber(obj) {
      if (!obj) return NaN;
      const s = String(obj.id || '');
      const m = s.match(/(\d+)/g);
      if (m && m.length) return parseInt(m[m.length-1], 10);
      if (obj.title) {
        const t = String(obj.title).match(/(\d+)/g);
        if (t && t.length) return parseInt(t[t.length-1], 10);
      }
      return NaN;
    }
    function escapeHTML(str){
      return String(str).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;' }[c]||c));
    }
    function splitTitle(full){
      if(!full) return { num:'', rest:'', dash:'' };
      const original = String(full);
      let m = original.match(/^((?:[Cc]h(?:apter)?\.?)\s*\d+)(.*)$/); // Chapter 123 ...
      if(!m){
        let m2 = original.match(/^(\d+)(.*)$/); // 123 ...
        if(!m2) return { num: original, rest:'', dash:'' };
        return separateDash(m2[1], m2[2]);
      }
      return separateDash(m[1].trim(), m[2]);
    }
  function separateDash(numPart, remainder){
      if(!remainder) return { num: numPart, dash:'', rest:'' };
      // Look for first dash-like separator (— or -) with optional surrounding spaces
      const dm = remainder.match(/^(\s*[–—-]\s*)(.*)$/); // capture dash+spaces then rest
      if(dm){
    let restStr = dm[2].replace(/^\s+/, '');
    // Force canonical spacing: single space before and after em dash
    const dashStr = ' — ';
    return { num: numPart, dash: dashStr, rest: restStr };
      }
      return { num: numPart, dash:'', rest: remainder };
    }
    let list = [...CHAPTERS];
    list.sort((a, b) => {
      const na = chapterNumber(a);
      const nb = chapterNumber(b);
      if (!isNaN(na) && !isNaN(nb)) return nb - na; // numeric descending
      if (!isNaN(na)) return -1; // put numeric ids before non-numeric
      if (!isNaN(nb)) return 1;
      // fallback to updated timestamp if present
      if (a.updated || b.updated) return new Date(b.updated || 0) - new Date(a.updated || 0);
      // final fallback: locale-aware id comparison (numeric aware)
      return String(b.id || '').localeCompare(String(a.id || ''), undefined, { numeric: true, sensitivity: 'base' });
    });
    list = list.slice(0, limit);
    if (list.length===0){ recentBody.innerHTML = '<div class="recent-empty">No chapters yet.</div>'; recentWrapper.hidden=false; return; }
    const rows = list.map(c=>{
      const dateStr = formatDate(c.updated);
      const id = c.id;
      const rawTitle = c.title || c.id;
  const { num, rest, dash } = splitTitle(rawTitle);
      const href = buildChapterHref(id);
  const numHTML = `<a class="chapter-number-link" href="${href}" data-chapter="${id}" data-chapter-title="${escapeHTML(rawTitle)}" aria-label="Open ${escapeHTML(rawTitle)}">${escapeHTML(num || rawTitle)}</a>`;
      let restHTML = '';
      const dashHTML = dash ? `<span class="chapter-dash">${escapeHTML(dash)}</span>` : '';
      if(rest && rest.trim().length>0){
        // Make the blurred portion an anchor so after reveal it can open the chapter
  restHTML = `<a class="spoiler-blur chapter-title-link" href="${href}" data-chapter="${id}" data-chapter-title="${escapeHTML(rawTitle)}" aria-label="Hidden chapter title - click to reveal then click again to open">${escapeHTML(rest)}</a>`;
      }
      return `<tr><td>${numHTML}${dashHTML}${restHTML}</td><td class="recent-date hide-narrow">${dateStr || ''}</td></tr>`;
    }).join('');
    recentBody.innerHTML = `<table class="recent-table"><thead><tr><th>Chapter</th><th class="hide-narrow">Updated</th></tr></thead><tbody>${rows}</tbody></table>`;
    if(!window._recentSpoilerHandlerAttached){
      recentBody.addEventListener('click', e=>{
        const a = e.target.closest('a[data-chapter]');
        if(!a) return;
        // If it's a blurred title and not yet revealed, reveal instead of opening
        if(a.classList.contains('spoiler-blur') && !a.classList.contains('revealed')){
          e.preventDefault();
          a.classList.add('revealed');
          a.setAttribute('aria-label', `Open ${a.getAttribute('data-chapter-title')||'chapter'}`);
          // Yandex Metrica goal for revealing a hidden title
          try { if (typeof ym==='function') ym(103953563, 'reachGoal', 'reveal_title', { chapter: a.getAttribute('data-chapter') }); } catch(_){ }
          return;
        }
        e.preventDefault();
        const id = a.getAttribute('data-chapter');
        openChapterById(id);
      });
      window._recentSpoilerHandlerAttached = true;
    }
    recentWrapper.hidden = false;
  }

  // ===== Yandex.Metrica virtual pageview tracking (chapter navigation) =====
  (function(){
    const METRICA_ID = 103953563;
    let lastVirtual = location.pathname + location.search;
    document.addEventListener('chapter:opened', ev=>{
      const id = ev.detail && ev.detail.id;
      if(!id || typeof ym!=='function') return;
      try {
        const ch = (window.CHAPTERS||[]).find(c=>c.id===id);
        const title = (ch && ch.title) ? ch.title : id;
        const virtualUrl = buildChapterHref(id);
        ym(METRICA_ID, 'hit', virtualUrl, { title: title + ' — ' + currentNovelLabel(), referer: lastVirtual });
        ym(METRICA_ID, 'reachGoal', 'open_chapter', { chapter: id });
        lastVirtual = virtualUrl;
      } catch(_){ }
    });
  })();

  </script>
</body>
</html>
